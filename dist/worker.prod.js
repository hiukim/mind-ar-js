/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/controller.worker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/is-any-array/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/is-any-array/src/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n\n\n//# sourceURL=webpack:///./node_modules/is-any-array/src/index.js?");

/***/ }),

/***/ "./node_modules/ml-array-max/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-max/lib-es6/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ \"./node_modules/is-any-array/src/index.js\");\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_any_array__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n * Computes the maximum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction max(input) {\n  if (!is_any_array__WEBPACK_IMPORTED_MODULE_0___default()(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var maxValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (max);\n\n\n//# sourceURL=webpack:///./node_modules/ml-array-max/lib-es6/index.js?");

/***/ }),

/***/ "./node_modules/ml-array-min/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-min/lib-es6/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ \"./node_modules/is-any-array/src/index.js\");\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_any_array__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n * Computes the minimum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction min(input) {\n  if (!is_any_array__WEBPACK_IMPORTED_MODULE_0___default()(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var minValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (min);\n\n\n//# sourceURL=webpack:///./node_modules/ml-array-min/lib-es6/index.js?");

/***/ }),

/***/ "./node_modules/ml-array-rescale/lib-es6/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ml-array-rescale/lib-es6/index.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ \"./node_modules/is-any-array/src/index.js\");\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(is_any_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ml_array_max__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ml-array-max */ \"./node_modules/ml-array-max/lib-es6/index.js\");\n/* harmony import */ var ml_array_min__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ml-array-min */ \"./node_modules/ml-array-min/lib-es6/index.js\");\n\n\n\n\n/**\n *\n * @param {Array} input\n * @param {object} [options={}]\n * @param {Array} [options.output=[]] specify the output array, can be the input array for in place modification\n */\n\nfunction rescale(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!is_any_array__WEBPACK_IMPORTED_MODULE_0___default()(input)) {\n    throw new TypeError('input must be an array');\n  } else if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!is_any_array__WEBPACK_IMPORTED_MODULE_0___default()(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  var currentMin = Object(ml_array_min__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(input);\n  var currentMax = Object(ml_array_max__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input);\n\n  if (currentMin === currentMax) {\n    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');\n  }\n\n  var _options$min = options.min,\n      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,\n      _options$max = options.max,\n      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;\n\n  if (minValue >= maxValue) {\n    throw new RangeError('min option must be smaller than max option');\n  }\n\n  var factor = (maxValue - minValue) / (currentMax - currentMin);\n\n  for (var i = 0; i < input.length; i++) {\n    output[i] = (input[i] - currentMin) * factor + minValue;\n  }\n\n  return output;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (rescale);\n\n\n//# sourceURL=webpack:///./node_modules/ml-array-rescale/lib-es6/index.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/correlation.js":
/*!***************************************************!*\
  !*** ./node_modules/ml-matrix/src/correlation.js ***!
  \***************************************************/
/*! exports provided: correlation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"correlation\", function() { return correlation; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n\n\nfunction correlation(xMatrix, yMatrix = xMatrix, options = {}) {\n  xMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](xMatrix);\n  let yIsSame = false;\n  if (\n    typeof yMatrix === 'object' &&\n    !_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isMatrix(yMatrix) &&\n    !Array.isArray(yMatrix)\n  ) {\n    options = yMatrix;\n    yMatrix = xMatrix;\n    yIsSame = true;\n  } else {\n    yMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](yMatrix);\n  }\n  if (xMatrix.rows !== yMatrix.rows) {\n    throw new TypeError('Both matrices must have the same number of rows');\n  }\n\n  const { center = true, scale = true } = options;\n  if (center) {\n    xMatrix.center('column');\n    if (!yIsSame) {\n      yMatrix.center('column');\n    }\n  }\n  if (scale) {\n    xMatrix.scale('column');\n    if (!yIsSame) {\n      yMatrix.scale('column');\n    }\n  }\n\n  const sdx = xMatrix.standardDeviation('column', { unbiased: true });\n  const sdy = yIsSame\n    ? sdx\n    : yMatrix.standardDeviation('column', { unbiased: true });\n\n  const corr = xMatrix.transpose().mmul(yMatrix);\n  for (let i = 0; i < corr.rows; i++) {\n    for (let j = 0; j < corr.columns; j++) {\n      corr.set(\n        i,\n        j,\n        corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1)),\n      );\n    }\n  }\n  return corr;\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/correlation.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/covariance.js":
/*!**************************************************!*\
  !*** ./node_modules/ml-matrix/src/covariance.js ***!
  \**************************************************/
/*! exports provided: covariance */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"covariance\", function() { return covariance; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n\n\nfunction covariance(xMatrix, yMatrix = xMatrix, options = {}) {\n  xMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](xMatrix);\n  let yIsSame = false;\n  if (\n    typeof yMatrix === 'object' &&\n    !_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isMatrix(yMatrix) &&\n    !Array.isArray(yMatrix)\n  ) {\n    options = yMatrix;\n    yMatrix = xMatrix;\n    yIsSame = true;\n  } else {\n    yMatrix = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](yMatrix);\n  }\n  if (xMatrix.rows !== yMatrix.rows) {\n    throw new TypeError('Both matrices must have the same number of rows');\n  }\n  const { center = true } = options;\n  if (center) {\n    xMatrix = xMatrix.center('column');\n    if (!yIsSame) {\n      yMatrix = yMatrix.center('column');\n    }\n  }\n  const cov = xMatrix.transpose().mmul(yMatrix);\n  for (let i = 0; i < cov.rows; i++) {\n    for (let j = 0; j < cov.columns; j++) {\n      cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));\n    }\n  }\n  return cov;\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/covariance.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/cholesky.js":
/*!***************************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/cholesky.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CholeskyDecomposition; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n\n\n\nclass CholeskyDecomposition {\n  constructor(value) {\n    value = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(value);\n    if (!value.isSymmetric()) {\n      throw new Error('Matrix is not symmetric');\n    }\n\n    let a = value;\n    let dimension = a.rows;\n    let l = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](dimension, dimension);\n    let positiveDefinite = true;\n    let i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n      let d = 0;\n      for (k = 0; k < j; k++) {\n        let s = 0;\n        for (i = 0; i < k; i++) {\n          s += l.get(k, i) * l.get(j, i);\n        }\n        s = (a.get(j, k) - s) / l.get(k, k);\n        l.set(j, k, s);\n        d = d + s * s;\n      }\n\n      d = a.get(j, j) - d;\n\n      positiveDefinite &= d > 0;\n      l.set(j, j, Math.sqrt(Math.max(d, 0)));\n      for (k = j + 1; k < dimension; k++) {\n        l.set(j, k, 0);\n      }\n    }\n\n    this.L = l;\n    this.positiveDefinite = Boolean(positiveDefinite);\n  }\n\n  isPositiveDefinite() {\n    return this.positiveDefinite;\n  }\n\n  solve(value) {\n    value = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(value);\n\n    let l = this.L;\n    let dimension = l.rows;\n\n    if (value.rows !== dimension) {\n      throw new Error('Matrix dimensions do not match');\n    }\n    if (this.isPositiveDefinite() === false) {\n      throw new Error('Matrix is not positive definite');\n    }\n\n    let count = value.columns;\n    let B = value.clone();\n    let i, j, k;\n\n    for (k = 0; k < dimension; k++) {\n      for (j = 0; j < count; j++) {\n        for (i = 0; i < k; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    for (k = dimension - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        for (i = k + 1; i < dimension; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    return B;\n  }\n\n  get lowerTriangularMatrix() {\n    return this.L;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/dc/cholesky.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/evd.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/evd.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return EigenvalueDecomposition; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./node_modules/ml-matrix/src/dc/util.js\");\n\n\n\n\n\nclass EigenvalueDecomposition {\n  constructor(matrix, options = {}) {\n    const { assumeSymmetric = false } = options;\n\n    matrix = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n      throw new Error('Matrix is not a square matrix');\n    }\n\n    let n = matrix.columns;\n    let V = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](n, n);\n    let d = new Float64Array(n);\n    let e = new Float64Array(n);\n    let value = matrix;\n    let i, j;\n\n    let isSymmetric = false;\n    if (assumeSymmetric) {\n      isSymmetric = true;\n    } else {\n      isSymmetric = matrix.isSymmetric();\n    }\n\n    if (isSymmetric) {\n      for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          V.set(i, j, value.get(i, j));\n        }\n      }\n      tred2(n, e, d, V);\n      tql2(n, e, d, V);\n    } else {\n      let H = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](n, n);\n      let ort = new Float64Array(n);\n      for (j = 0; j < n; j++) {\n        for (i = 0; i < n; i++) {\n          H.set(i, j, value.get(i, j));\n        }\n      }\n      orthes(n, H, ort, V);\n      hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n  }\n\n  get realEigenvalues() {\n    return Array.from(this.d);\n  }\n\n  get imaginaryEigenvalues() {\n    return Array.from(this.e);\n  }\n\n  get eigenvectorMatrix() {\n    return this.V;\n  }\n\n  get diagonalMatrix() {\n    let n = this.n;\n    let e = this.e;\n    let d = this.d;\n    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](n, n);\n    let i, j;\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        X.set(i, j, 0);\n      }\n      X.set(i, i, d[i]);\n      if (e[i] > 0) {\n        X.set(i, i + 1, e[i]);\n      } else if (e[i] < 0) {\n        X.set(i, i - 1, e[i]);\n      }\n    }\n    return X;\n  }\n}\n\nfunction tred2(n, e, d, V) {\n  let f, g, h, i, j, k, hh, scale;\n\n  for (j = 0; j < n; j++) {\n    d[j] = V.get(n - 1, j);\n  }\n\n  for (i = n - 1; i > 0; i--) {\n    scale = 0;\n    h = 0;\n    for (k = 0; k < i; k++) {\n      scale = scale + Math.abs(d[k]);\n    }\n\n    if (scale === 0) {\n      e[i] = d[i - 1];\n      for (j = 0; j < i; j++) {\n        d[j] = V.get(i - 1, j);\n        V.set(i, j, 0);\n        V.set(j, i, 0);\n      }\n    } else {\n      for (k = 0; k < i; k++) {\n        d[k] /= scale;\n        h += d[k] * d[k];\n      }\n\n      f = d[i - 1];\n      g = Math.sqrt(h);\n      if (f > 0) {\n        g = -g;\n      }\n\n      e[i] = scale * g;\n      h = h - f * g;\n      d[i - 1] = f - g;\n      for (j = 0; j < i; j++) {\n        e[j] = 0;\n      }\n\n      for (j = 0; j < i; j++) {\n        f = d[j];\n        V.set(j, i, f);\n        g = e[j] + V.get(j, j) * f;\n        for (k = j + 1; k <= i - 1; k++) {\n          g += V.get(k, j) * d[k];\n          e[k] += V.get(k, j) * f;\n        }\n        e[j] = g;\n      }\n\n      f = 0;\n      for (j = 0; j < i; j++) {\n        e[j] /= h;\n        f += e[j] * d[j];\n      }\n\n      hh = f / (h + h);\n      for (j = 0; j < i; j++) {\n        e[j] -= hh * d[j];\n      }\n\n      for (j = 0; j < i; j++) {\n        f = d[j];\n        g = e[j];\n        for (k = j; k <= i - 1; k++) {\n          V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));\n        }\n        d[j] = V.get(i - 1, j);\n        V.set(i, j, 0);\n      }\n    }\n    d[i] = h;\n  }\n\n  for (i = 0; i < n - 1; i++) {\n    V.set(n - 1, i, V.get(i, i));\n    V.set(i, i, 1);\n    h = d[i + 1];\n    if (h !== 0) {\n      for (k = 0; k <= i; k++) {\n        d[k] = V.get(k, i + 1) / h;\n      }\n\n      for (j = 0; j <= i; j++) {\n        g = 0;\n        for (k = 0; k <= i; k++) {\n          g += V.get(k, i + 1) * V.get(k, j);\n        }\n        for (k = 0; k <= i; k++) {\n          V.set(k, j, V.get(k, j) - g * d[k]);\n        }\n      }\n    }\n\n    for (k = 0; k <= i; k++) {\n      V.set(k, i + 1, 0);\n    }\n  }\n\n  for (j = 0; j < n; j++) {\n    d[j] = V.get(n - 1, j);\n    V.set(n - 1, j, 0);\n  }\n\n  V.set(n - 1, n - 1, 1);\n  e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n  let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;\n\n  for (i = 1; i < n; i++) {\n    e[i - 1] = e[i];\n  }\n\n  e[n - 1] = 0;\n\n  let f = 0;\n  let tst1 = 0;\n  let eps = Number.EPSILON;\n\n  for (l = 0; l < n; l++) {\n    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n    m = l;\n    while (m < n) {\n      if (Math.abs(e[m]) <= eps * tst1) {\n        break;\n      }\n      m++;\n    }\n\n    if (m > l) {\n      iter = 0;\n      do {\n        iter = iter + 1;\n\n        g = d[l];\n        p = (d[l + 1] - g) / (2 * e[l]);\n        r = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"hypotenuse\"])(p, 1);\n        if (p < 0) {\n          r = -r;\n        }\n\n        d[l] = e[l] / (p + r);\n        d[l + 1] = e[l] * (p + r);\n        dl1 = d[l + 1];\n        h = g - d[l];\n        for (i = l + 2; i < n; i++) {\n          d[i] -= h;\n        }\n\n        f = f + h;\n\n        p = d[m];\n        c = 1;\n        c2 = c;\n        c3 = c;\n        el1 = e[l + 1];\n        s = 0;\n        s2 = 0;\n        for (i = m - 1; i >= l; i--) {\n          c3 = c2;\n          c2 = c;\n          s2 = s;\n          g = c * e[i];\n          h = c * p;\n          r = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"hypotenuse\"])(p, e[i]);\n          e[i + 1] = s * r;\n          s = e[i] / r;\n          c = p / r;\n          p = c * d[i] - s * g;\n          d[i + 1] = h + s * (c * g + s * d[i]);\n\n          for (k = 0; k < n; k++) {\n            h = V.get(k, i + 1);\n            V.set(k, i + 1, s * V.get(k, i) + c * h);\n            V.set(k, i, c * V.get(k, i) - s * h);\n          }\n        }\n\n        p = (-s * s2 * c3 * el1 * e[l]) / dl1;\n        e[l] = s * p;\n        d[l] = c * p;\n      } while (Math.abs(e[l]) > eps * tst1);\n    }\n    d[l] = d[l] + f;\n    e[l] = 0;\n  }\n\n  for (i = 0; i < n - 1; i++) {\n    k = i;\n    p = d[i];\n    for (j = i + 1; j < n; j++) {\n      if (d[j] < p) {\n        k = j;\n        p = d[j];\n      }\n    }\n\n    if (k !== i) {\n      d[k] = d[i];\n      d[i] = p;\n      for (j = 0; j < n; j++) {\n        p = V.get(j, i);\n        V.set(j, i, V.get(j, k));\n        V.set(j, k, p);\n      }\n    }\n  }\n}\n\nfunction orthes(n, H, ort, V) {\n  let low = 0;\n  let high = n - 1;\n  let f, g, h, i, j, m;\n  let scale;\n\n  for (m = low + 1; m <= high - 1; m++) {\n    scale = 0;\n    for (i = m; i <= high; i++) {\n      scale = scale + Math.abs(H.get(i, m - 1));\n    }\n\n    if (scale !== 0) {\n      h = 0;\n      for (i = high; i >= m; i--) {\n        ort[i] = H.get(i, m - 1) / scale;\n        h += ort[i] * ort[i];\n      }\n\n      g = Math.sqrt(h);\n      if (ort[m] > 0) {\n        g = -g;\n      }\n\n      h = h - ort[m] * g;\n      ort[m] = ort[m] - g;\n\n      for (j = m; j < n; j++) {\n        f = 0;\n        for (i = high; i >= m; i--) {\n          f += ort[i] * H.get(i, j);\n        }\n\n        f = f / h;\n        for (i = m; i <= high; i++) {\n          H.set(i, j, H.get(i, j) - f * ort[i]);\n        }\n      }\n\n      for (i = 0; i <= high; i++) {\n        f = 0;\n        for (j = high; j >= m; j--) {\n          f += ort[j] * H.get(i, j);\n        }\n\n        f = f / h;\n        for (j = m; j <= high; j++) {\n          H.set(i, j, H.get(i, j) - f * ort[j]);\n        }\n      }\n\n      ort[m] = scale * ort[m];\n      H.set(m, m - 1, scale * g);\n    }\n  }\n\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      V.set(i, j, i === j ? 1 : 0);\n    }\n  }\n\n  for (m = high - 1; m >= low + 1; m--) {\n    if (H.get(m, m - 1) !== 0) {\n      for (i = m + 1; i <= high; i++) {\n        ort[i] = H.get(i, m - 1);\n      }\n\n      for (j = m; j <= high; j++) {\n        g = 0;\n        for (i = m; i <= high; i++) {\n          g += ort[i] * V.get(i, j);\n        }\n\n        g = g / ort[m] / H.get(m, m - 1);\n        for (i = m; i <= high; i++) {\n          V.set(i, j, V.get(i, j) + g * ort[i]);\n        }\n      }\n    }\n  }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n  let n = nn - 1;\n  let low = 0;\n  let high = nn - 1;\n  let eps = Number.EPSILON;\n  let exshift = 0;\n  let norm = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let z = 0;\n  let iter = 0;\n  let i, j, k, l, m, t, w, x, y;\n  let ra, sa, vr, vi;\n  let notlast, cdivres;\n\n  for (i = 0; i < nn; i++) {\n    if (i < low || i > high) {\n      d[i] = H.get(i, i);\n      e[i] = 0;\n    }\n\n    for (j = Math.max(i - 1, 0); j < nn; j++) {\n      norm = norm + Math.abs(H.get(i, j));\n    }\n  }\n\n  while (n >= low) {\n    l = n;\n    while (l > low) {\n      s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));\n      if (s === 0) {\n        s = norm;\n      }\n      if (Math.abs(H.get(l, l - 1)) < eps * s) {\n        break;\n      }\n      l--;\n    }\n\n    if (l === n) {\n      H.set(n, n, H.get(n, n) + exshift);\n      d[n] = H.get(n, n);\n      e[n] = 0;\n      n--;\n      iter = 0;\n    } else if (l === n - 1) {\n      w = H.get(n, n - 1) * H.get(n - 1, n);\n      p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;\n      q = p * p + w;\n      z = Math.sqrt(Math.abs(q));\n      H.set(n, n, H.get(n, n) + exshift);\n      H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);\n      x = H.get(n, n);\n\n      if (q >= 0) {\n        z = p >= 0 ? p + z : p - z;\n        d[n - 1] = x + z;\n        d[n] = d[n - 1];\n        if (z !== 0) {\n          d[n] = x - w / z;\n        }\n        e[n - 1] = 0;\n        e[n] = 0;\n        x = H.get(n, n - 1);\n        s = Math.abs(x) + Math.abs(z);\n        p = x / s;\n        q = z / s;\n        r = Math.sqrt(p * p + q * q);\n        p = p / r;\n        q = q / r;\n\n        for (j = n - 1; j < nn; j++) {\n          z = H.get(n - 1, j);\n          H.set(n - 1, j, q * z + p * H.get(n, j));\n          H.set(n, j, q * H.get(n, j) - p * z);\n        }\n\n        for (i = 0; i <= n; i++) {\n          z = H.get(i, n - 1);\n          H.set(i, n - 1, q * z + p * H.get(i, n));\n          H.set(i, n, q * H.get(i, n) - p * z);\n        }\n\n        for (i = low; i <= high; i++) {\n          z = V.get(i, n - 1);\n          V.set(i, n - 1, q * z + p * V.get(i, n));\n          V.set(i, n, q * V.get(i, n) - p * z);\n        }\n      } else {\n        d[n - 1] = x + p;\n        d[n] = x + p;\n        e[n - 1] = z;\n        e[n] = -z;\n      }\n\n      n = n - 2;\n      iter = 0;\n    } else {\n      x = H.get(n, n);\n      y = 0;\n      w = 0;\n      if (l < n) {\n        y = H.get(n - 1, n - 1);\n        w = H.get(n, n - 1) * H.get(n - 1, n);\n      }\n\n      if (iter === 10) {\n        exshift += x;\n        for (i = low; i <= n; i++) {\n          H.set(i, i, H.get(i, i) - x);\n        }\n        s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));\n        x = y = 0.75 * s;\n        w = -0.4375 * s * s;\n      }\n\n      if (iter === 30) {\n        s = (y - x) / 2;\n        s = s * s + w;\n        if (s > 0) {\n          s = Math.sqrt(s);\n          if (y < x) {\n            s = -s;\n          }\n          s = x - w / ((y - x) / 2 + s);\n          for (i = low; i <= n; i++) {\n            H.set(i, i, H.get(i, i) - s);\n          }\n          exshift += s;\n          x = y = w = 0.964;\n        }\n      }\n\n      iter = iter + 1;\n\n      m = n - 2;\n      while (m >= l) {\n        z = H.get(m, m);\n        r = x - z;\n        s = y - z;\n        p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);\n        q = H.get(m + 1, m + 1) - z - r - s;\n        r = H.get(m + 2, m + 1);\n        s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n        p = p / s;\n        q = q / s;\n        r = r / s;\n        if (m === l) {\n          break;\n        }\n        if (\n          Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <\n          eps *\n            (Math.abs(p) *\n              (Math.abs(H.get(m - 1, m - 1)) +\n                Math.abs(z) +\n                Math.abs(H.get(m + 1, m + 1))))\n        ) {\n          break;\n        }\n        m--;\n      }\n\n      for (i = m + 2; i <= n; i++) {\n        H.set(i, i - 2, 0);\n        if (i > m + 2) {\n          H.set(i, i - 3, 0);\n        }\n      }\n\n      for (k = m; k <= n - 1; k++) {\n        notlast = k !== n - 1;\n        if (k !== m) {\n          p = H.get(k, k - 1);\n          q = H.get(k + 1, k - 1);\n          r = notlast ? H.get(k + 2, k - 1) : 0;\n          x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n          if (x !== 0) {\n            p = p / x;\n            q = q / x;\n            r = r / x;\n          }\n        }\n\n        if (x === 0) {\n          break;\n        }\n\n        s = Math.sqrt(p * p + q * q + r * r);\n        if (p < 0) {\n          s = -s;\n        }\n\n        if (s !== 0) {\n          if (k !== m) {\n            H.set(k, k - 1, -s * x);\n          } else if (l !== m) {\n            H.set(k, k - 1, -H.get(k, k - 1));\n          }\n\n          p = p + s;\n          x = p / s;\n          y = q / s;\n          z = r / s;\n          q = q / p;\n          r = r / p;\n\n          for (j = k; j < nn; j++) {\n            p = H.get(k, j) + q * H.get(k + 1, j);\n            if (notlast) {\n              p = p + r * H.get(k + 2, j);\n              H.set(k + 2, j, H.get(k + 2, j) - p * z);\n            }\n\n            H.set(k, j, H.get(k, j) - p * x);\n            H.set(k + 1, j, H.get(k + 1, j) - p * y);\n          }\n\n          for (i = 0; i <= Math.min(n, k + 3); i++) {\n            p = x * H.get(i, k) + y * H.get(i, k + 1);\n            if (notlast) {\n              p = p + z * H.get(i, k + 2);\n              H.set(i, k + 2, H.get(i, k + 2) - p * r);\n            }\n\n            H.set(i, k, H.get(i, k) - p);\n            H.set(i, k + 1, H.get(i, k + 1) - p * q);\n          }\n\n          for (i = low; i <= high; i++) {\n            p = x * V.get(i, k) + y * V.get(i, k + 1);\n            if (notlast) {\n              p = p + z * V.get(i, k + 2);\n              V.set(i, k + 2, V.get(i, k + 2) - p * r);\n            }\n\n            V.set(i, k, V.get(i, k) - p);\n            V.set(i, k + 1, V.get(i, k + 1) - p * q);\n          }\n        }\n      }\n    }\n  }\n\n  if (norm === 0) {\n    return;\n  }\n\n  for (n = nn - 1; n >= 0; n--) {\n    p = d[n];\n    q = e[n];\n\n    if (q === 0) {\n      l = n;\n      H.set(n, n, 1);\n      for (i = n - 1; i >= 0; i--) {\n        w = H.get(i, i) - p;\n        r = 0;\n        for (j = l; j <= n; j++) {\n          r = r + H.get(i, j) * H.get(j, n);\n        }\n\n        if (e[i] < 0) {\n          z = w;\n          s = r;\n        } else {\n          l = i;\n          if (e[i] === 0) {\n            H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));\n          } else {\n            x = H.get(i, i + 1);\n            y = H.get(i + 1, i);\n            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n            t = (x * s - z * r) / q;\n            H.set(i, n, t);\n            H.set(\n              i + 1,\n              n,\n              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z,\n            );\n          }\n\n          t = Math.abs(H.get(i, n));\n          if (eps * t * t > 1) {\n            for (j = i; j <= n; j++) {\n              H.set(j, n, H.get(j, n) / t);\n            }\n          }\n        }\n      }\n    } else if (q < 0) {\n      l = n - 1;\n\n      if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {\n        H.set(n - 1, n - 1, q / H.get(n, n - 1));\n        H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));\n      } else {\n        cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);\n        H.set(n - 1, n - 1, cdivres[0]);\n        H.set(n - 1, n, cdivres[1]);\n      }\n\n      H.set(n, n - 1, 0);\n      H.set(n, n, 1);\n      for (i = n - 2; i >= 0; i--) {\n        ra = 0;\n        sa = 0;\n        for (j = l; j <= n; j++) {\n          ra = ra + H.get(i, j) * H.get(j, n - 1);\n          sa = sa + H.get(i, j) * H.get(j, n);\n        }\n\n        w = H.get(i, i) - p;\n\n        if (e[i] < 0) {\n          z = w;\n          r = ra;\n          s = sa;\n        } else {\n          l = i;\n          if (e[i] === 0) {\n            cdivres = cdiv(-ra, -sa, w, q);\n            H.set(i, n - 1, cdivres[0]);\n            H.set(i, n, cdivres[1]);\n          } else {\n            x = H.get(i, i + 1);\n            y = H.get(i + 1, i);\n            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n            vi = (d[i] - p) * 2 * q;\n            if (vr === 0 && vi === 0) {\n              vr =\n                eps *\n                norm *\n                (Math.abs(w) +\n                  Math.abs(q) +\n                  Math.abs(x) +\n                  Math.abs(y) +\n                  Math.abs(z));\n            }\n            cdivres = cdiv(\n              x * r - z * ra + q * sa,\n              x * s - z * sa - q * ra,\n              vr,\n              vi,\n            );\n            H.set(i, n - 1, cdivres[0]);\n            H.set(i, n, cdivres[1]);\n            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {\n              H.set(\n                i + 1,\n                n - 1,\n                (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x,\n              );\n              H.set(\n                i + 1,\n                n,\n                (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x,\n              );\n            } else {\n              cdivres = cdiv(\n                -r - y * H.get(i, n - 1),\n                -s - y * H.get(i, n),\n                z,\n                q,\n              );\n              H.set(i + 1, n - 1, cdivres[0]);\n              H.set(i + 1, n, cdivres[1]);\n            }\n          }\n\n          t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));\n          if (eps * t * t > 1) {\n            for (j = i; j <= n; j++) {\n              H.set(j, n - 1, H.get(j, n - 1) / t);\n              H.set(j, n, H.get(j, n) / t);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < nn; i++) {\n    if (i < low || i > high) {\n      for (j = i; j < nn; j++) {\n        V.set(i, j, H.get(i, j));\n      }\n    }\n  }\n\n  for (j = nn - 1; j >= low; j--) {\n    for (i = low; i <= high; i++) {\n      z = 0;\n      for (k = low; k <= Math.min(j, high); k++) {\n        z = z + V.get(i, k) * H.get(k, j);\n      }\n      V.set(i, j, z);\n    }\n  }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n  let r, d;\n  if (Math.abs(yr) > Math.abs(yi)) {\n    r = yi / yr;\n    d = yr + r * yi;\n    return [(xr + r * xi) / d, (xi - r * xr) / d];\n  } else {\n    r = yr / yi;\n    d = yi + r * yr;\n    return [(r * xr + xi) / d, (r * xi - xr) / d];\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/dc/evd.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/lu.js":
/*!*********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/lu.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return LuDecomposition; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n\n\n\nclass LuDecomposition {\n  constructor(matrix) {\n    matrix = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(matrix);\n\n    let lu = matrix.clone();\n    let rows = lu.rows;\n    let columns = lu.columns;\n    let pivotVector = new Float64Array(rows);\n    let pivotSign = 1;\n    let i, j, k, p, s, t, v;\n    let LUcolj, kmax;\n\n    for (i = 0; i < rows; i++) {\n      pivotVector[i] = i;\n    }\n\n    LUcolj = new Float64Array(rows);\n\n    for (j = 0; j < columns; j++) {\n      for (i = 0; i < rows; i++) {\n        LUcolj[i] = lu.get(i, j);\n      }\n\n      for (i = 0; i < rows; i++) {\n        kmax = Math.min(i, j);\n        s = 0;\n        for (k = 0; k < kmax; k++) {\n          s += lu.get(i, k) * LUcolj[k];\n        }\n        LUcolj[i] -= s;\n        lu.set(i, j, LUcolj[i]);\n      }\n\n      p = j;\n      for (i = j + 1; i < rows; i++) {\n        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\n          p = i;\n        }\n      }\n\n      if (p !== j) {\n        for (k = 0; k < columns; k++) {\n          t = lu.get(p, k);\n          lu.set(p, k, lu.get(j, k));\n          lu.set(j, k, t);\n        }\n\n        v = pivotVector[p];\n        pivotVector[p] = pivotVector[j];\n        pivotVector[j] = v;\n\n        pivotSign = -pivotSign;\n      }\n\n      if (j < rows && lu.get(j, j) !== 0) {\n        for (i = j + 1; i < rows; i++) {\n          lu.set(i, j, lu.get(i, j) / lu.get(j, j));\n        }\n      }\n    }\n\n    this.LU = lu;\n    this.pivotVector = pivotVector;\n    this.pivotSign = pivotSign;\n  }\n\n  isSingular() {\n    let data = this.LU;\n    let col = data.columns;\n    for (let j = 0; j < col; j++) {\n      if (data.get(j, j) === 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  solve(value) {\n    value = _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].checkMatrix(value);\n\n    let lu = this.LU;\n    let rows = lu.rows;\n\n    if (rows !== value.rows) {\n      throw new Error('Invalid matrix dimensions');\n    }\n    if (this.isSingular()) {\n      throw new Error('LU matrix is singular');\n    }\n\n    let count = value.columns;\n    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);\n    let columns = lu.columns;\n    let i, j, k;\n\n    for (k = 0; k < columns; k++) {\n      for (i = k + 1; i < columns; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n        }\n      }\n    }\n    for (k = columns - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        X.set(k, j, X.get(k, j) / lu.get(k, k));\n      }\n      for (i = 0; i < k; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));\n        }\n      }\n    }\n    return X;\n  }\n\n  get determinant() {\n    let data = this.LU;\n    if (!data.isSquare()) {\n      throw new Error('Matrix must be square');\n    }\n    let determinant = this.pivotSign;\n    let col = data.columns;\n    for (let j = 0; j < col; j++) {\n      determinant *= data.get(j, j);\n    }\n    return determinant;\n  }\n\n  get lowerTriangularMatrix() {\n    let data = this.LU;\n    let rows = data.rows;\n    let columns = data.columns;\n    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        if (i > j) {\n          X.set(i, j, data.get(i, j));\n        } else if (i === j) {\n          X.set(i, j, 1);\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get upperTriangularMatrix() {\n    let data = this.LU;\n    let rows = data.rows;\n    let columns = data.columns;\n    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        if (i <= j) {\n          X.set(i, j, data.get(i, j));\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get pivotPermutationVector() {\n    return Array.from(this.pivotVector);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/dc/lu.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/nipals.js":
/*!*************************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/nipals.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return nipals; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n\n\n\nclass nipals {\n  constructor(X, options = {}) {\n    X = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(X);\n    let { Y } = options;\n    const {\n      scaleScores = false,\n      maxIterations = 1000,\n      terminationCriteria = 1e-10,\n    } = options;\n\n    let u;\n    if (Y) {\n      if (Array.isArray(Y) && typeof Y[0] === 'number') {\n        Y = _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].columnVector(Y);\n      } else {\n        Y = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(Y);\n      }\n      if (!Y.isColumnVector() || Y.rows !== X.rows) {\n        throw new Error('Y must be a column vector of length X.rows');\n      }\n      u = Y;\n    } else {\n      u = X.getColumnVector(0);\n    }\n\n    let diff = 1;\n    let t, q, w, tOld;\n\n    for (\n      let counter = 0;\n      counter < maxIterations && diff > terminationCriteria;\n      counter++\n    ) {\n      w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));\n      w = w.div(w.norm());\n\n      t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));\n\n      if (counter > 0) {\n        diff = t.clone().sub(tOld).pow(2).sum();\n      }\n      tOld = t.clone();\n\n      if (Y) {\n        q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n        q = q.div(q.norm());\n\n        u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));\n      } else {\n        u = t;\n      }\n    }\n\n    if (Y) {\n      let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n      p = p.div(p.norm());\n      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));\n      let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));\n      let yResidual = Y.clone().sub(\n        t.clone().mulS(residual.get(0, 0)).mmul(q.transpose()),\n      );\n\n      this.t = t;\n      this.p = p.transpose();\n      this.w = w.transpose();\n      this.q = q;\n      this.u = u;\n      this.s = t.transpose().mmul(t);\n      this.xResidual = xResidual;\n      this.yResidual = yResidual;\n      this.betas = residual;\n    } else {\n      this.w = w.transpose();\n      this.s = t.transpose().mmul(t).sqrt();\n      if (scaleScores) {\n        this.t = t.clone().div(this.s.get(0, 0));\n      } else {\n        this.t = t;\n      }\n      this.xResidual = X.sub(t.mmul(w.transpose()));\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/dc/nipals.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/qr.js":
/*!*********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/qr.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return QrDecomposition; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./node_modules/ml-matrix/src/dc/util.js\");\n\n\n\n\n\nclass QrDecomposition {\n  constructor(value) {\n    value = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(value);\n\n    let qr = value.clone();\n    let m = value.rows;\n    let n = value.columns;\n    let rdiag = new Float64Array(n);\n    let i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n      let nrm = 0;\n      for (i = k; i < m; i++) {\n        nrm = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"hypotenuse\"])(nrm, qr.get(i, k));\n      }\n      if (nrm !== 0) {\n        if (qr.get(k, k) < 0) {\n          nrm = -nrm;\n        }\n        for (i = k; i < m; i++) {\n          qr.set(i, k, qr.get(i, k) / nrm);\n        }\n        qr.set(k, k, qr.get(k, k) + 1);\n        for (j = k + 1; j < n; j++) {\n          s = 0;\n          for (i = k; i < m; i++) {\n            s += qr.get(i, k) * qr.get(i, j);\n          }\n          s = -s / qr.get(k, k);\n          for (i = k; i < m; i++) {\n            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n      rdiag[k] = -nrm;\n    }\n\n    this.QR = qr;\n    this.Rdiag = rdiag;\n  }\n\n  solve(value) {\n    value = _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].checkMatrix(value);\n\n    let qr = this.QR;\n    let m = qr.rows;\n\n    if (value.rows !== m) {\n      throw new Error('Matrix row dimensions must agree');\n    }\n    if (!this.isFullRank()) {\n      throw new Error('Matrix is rank deficient');\n    }\n\n    let count = value.columns;\n    let X = value.clone();\n    let n = qr.columns;\n    let i, j, k, s;\n\n    for (k = 0; k < n; k++) {\n      for (j = 0; j < count; j++) {\n        s = 0;\n        for (i = k; i < m; i++) {\n          s += qr.get(i, k) * X.get(i, j);\n        }\n        s = -s / qr.get(k, k);\n        for (i = k; i < m; i++) {\n          X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n        }\n      }\n    }\n    for (k = n - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        X.set(k, j, X.get(k, j) / this.Rdiag[k]);\n      }\n      for (i = 0; i < k; i++) {\n        for (j = 0; j < count; j++) {\n          X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));\n        }\n      }\n    }\n\n    return X.subMatrix(0, n - 1, 0, count - 1);\n  }\n\n  isFullRank() {\n    let columns = this.QR.columns;\n    for (let i = 0; i < columns; i++) {\n      if (this.Rdiag[i] === 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  get upperTriangularMatrix() {\n    let qr = this.QR;\n    let n = qr.columns;\n    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](n, n);\n    let i, j;\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        if (i < j) {\n          X.set(i, j, qr.get(i, j));\n        } else if (i === j) {\n          X.set(i, j, this.Rdiag[i]);\n        } else {\n          X.set(i, j, 0);\n        }\n      }\n    }\n    return X;\n  }\n\n  get orthogonalMatrix() {\n    let qr = this.QR;\n    let rows = qr.rows;\n    let columns = qr.columns;\n    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](rows, columns);\n    let i, j, k, s;\n\n    for (k = columns - 1; k >= 0; k--) {\n      for (i = 0; i < rows; i++) {\n        X.set(i, k, 0);\n      }\n      X.set(k, k, 1);\n      for (j = k; j < columns; j++) {\n        if (qr.get(k, k) !== 0) {\n          s = 0;\n          for (i = k; i < rows; i++) {\n            s += qr.get(i, k) * X.get(i, j);\n          }\n\n          s = -s / qr.get(k, k);\n\n          for (i = k; i < rows; i++) {\n            X.set(i, j, X.get(i, j) + s * qr.get(i, k));\n          }\n        }\n      }\n    }\n    return X;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/dc/qr.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/svd.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/svd.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SingularValueDecomposition; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./node_modules/ml-matrix/src/dc/util.js\");\n\n\n\n\n\nclass SingularValueDecomposition {\n  constructor(value, options = {}) {\n    value = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(value);\n\n    let m = value.rows;\n    let n = value.columns;\n\n    const {\n      computeLeftSingularVectors = true,\n      computeRightSingularVectors = true,\n      autoTranspose = false,\n    } = options;\n\n    let wantu = Boolean(computeLeftSingularVectors);\n    let wantv = Boolean(computeRightSingularVectors);\n\n    let swapped = false;\n    let a;\n    if (m < n) {\n      if (!autoTranspose) {\n        a = value.clone();\n        // eslint-disable-next-line no-console\n        console.warn(\n          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',\n        );\n      } else {\n        a = value.transpose();\n        m = a.rows;\n        n = a.columns;\n        swapped = true;\n        let aux = wantu;\n        wantu = wantv;\n        wantv = aux;\n      }\n    } else {\n      a = value.clone();\n    }\n\n    let nu = Math.min(m, n);\n    let ni = Math.min(m + 1, n);\n    let s = new Float64Array(ni);\n    let U = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](m, nu);\n    let V = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](n, n);\n\n    let e = new Float64Array(n);\n    let work = new Float64Array(m);\n\n    let si = new Float64Array(ni);\n    for (let i = 0; i < ni; i++) si[i] = i;\n\n    let nct = Math.min(m - 1, n);\n    let nrt = Math.max(0, Math.min(n - 2, m));\n    let mrc = Math.max(nct, nrt);\n\n    for (let k = 0; k < mrc; k++) {\n      if (k < nct) {\n        s[k] = 0;\n        for (let i = k; i < m; i++) {\n          s[k] = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"hypotenuse\"])(s[k], a.get(i, k));\n        }\n        if (s[k] !== 0) {\n          if (a.get(k, k) < 0) {\n            s[k] = -s[k];\n          }\n          for (let i = k; i < m; i++) {\n            a.set(i, k, a.get(i, k) / s[k]);\n          }\n          a.set(k, k, a.get(k, k) + 1);\n        }\n        s[k] = -s[k];\n      }\n\n      for (let j = k + 1; j < n; j++) {\n        if (k < nct && s[k] !== 0) {\n          let t = 0;\n          for (let i = k; i < m; i++) {\n            t += a.get(i, k) * a.get(i, j);\n          }\n          t = -t / a.get(k, k);\n          for (let i = k; i < m; i++) {\n            a.set(i, j, a.get(i, j) + t * a.get(i, k));\n          }\n        }\n        e[j] = a.get(k, j);\n      }\n\n      if (wantu && k < nct) {\n        for (let i = k; i < m; i++) {\n          U.set(i, k, a.get(i, k));\n        }\n      }\n\n      if (k < nrt) {\n        e[k] = 0;\n        for (let i = k + 1; i < n; i++) {\n          e[k] = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"hypotenuse\"])(e[k], e[i]);\n        }\n        if (e[k] !== 0) {\n          if (e[k + 1] < 0) {\n            e[k] = 0 - e[k];\n          }\n          for (let i = k + 1; i < n; i++) {\n            e[i] /= e[k];\n          }\n          e[k + 1] += 1;\n        }\n        e[k] = -e[k];\n        if (k + 1 < m && e[k] !== 0) {\n          for (let i = k + 1; i < m; i++) {\n            work[i] = 0;\n          }\n          for (let i = k + 1; i < m; i++) {\n            for (let j = k + 1; j < n; j++) {\n              work[i] += e[j] * a.get(i, j);\n            }\n          }\n          for (let j = k + 1; j < n; j++) {\n            let t = -e[j] / e[k + 1];\n            for (let i = k + 1; i < m; i++) {\n              a.set(i, j, a.get(i, j) + t * work[i]);\n            }\n          }\n        }\n        if (wantv) {\n          for (let i = k + 1; i < n; i++) {\n            V.set(i, k, e[i]);\n          }\n        }\n      }\n    }\n\n    let p = Math.min(n, m + 1);\n    if (nct < n) {\n      s[nct] = a.get(nct, nct);\n    }\n    if (m < p) {\n      s[p - 1] = 0;\n    }\n    if (nrt + 1 < p) {\n      e[nrt] = a.get(nrt, p - 1);\n    }\n    e[p - 1] = 0;\n\n    if (wantu) {\n      for (let j = nct; j < nu; j++) {\n        for (let i = 0; i < m; i++) {\n          U.set(i, j, 0);\n        }\n        U.set(j, j, 1);\n      }\n      for (let k = nct - 1; k >= 0; k--) {\n        if (s[k] !== 0) {\n          for (let j = k + 1; j < nu; j++) {\n            let t = 0;\n            for (let i = k; i < m; i++) {\n              t += U.get(i, k) * U.get(i, j);\n            }\n            t = -t / U.get(k, k);\n            for (let i = k; i < m; i++) {\n              U.set(i, j, U.get(i, j) + t * U.get(i, k));\n            }\n          }\n          for (let i = k; i < m; i++) {\n            U.set(i, k, -U.get(i, k));\n          }\n          U.set(k, k, 1 + U.get(k, k));\n          for (let i = 0; i < k - 1; i++) {\n            U.set(i, k, 0);\n          }\n        } else {\n          for (let i = 0; i < m; i++) {\n            U.set(i, k, 0);\n          }\n          U.set(k, k, 1);\n        }\n      }\n    }\n\n    if (wantv) {\n      for (let k = n - 1; k >= 0; k--) {\n        if (k < nrt && e[k] !== 0) {\n          for (let j = k + 1; j < n; j++) {\n            let t = 0;\n            for (let i = k + 1; i < n; i++) {\n              t += V.get(i, k) * V.get(i, j);\n            }\n            t = -t / V.get(k + 1, k);\n            for (let i = k + 1; i < n; i++) {\n              V.set(i, j, V.get(i, j) + t * V.get(i, k));\n            }\n          }\n        }\n        for (let i = 0; i < n; i++) {\n          V.set(i, k, 0);\n        }\n        V.set(k, k, 1);\n      }\n    }\n\n    let pp = p - 1;\n    let iter = 0;\n    let eps = Number.EPSILON;\n    while (p > 0) {\n      let k, kase;\n      for (k = p - 2; k >= -1; k--) {\n        if (k === -1) {\n          break;\n        }\n        const alpha =\n          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));\n        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {\n          e[k] = 0;\n          break;\n        }\n      }\n      if (k === p - 2) {\n        kase = 4;\n      } else {\n        let ks;\n        for (ks = p - 1; ks >= k; ks--) {\n          if (ks === k) {\n            break;\n          }\n          let t =\n            (ks !== p ? Math.abs(e[ks]) : 0) +\n            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\n          if (Math.abs(s[ks]) <= eps * t) {\n            s[ks] = 0;\n            break;\n          }\n        }\n        if (ks === k) {\n          kase = 3;\n        } else if (ks === p - 1) {\n          kase = 1;\n        } else {\n          kase = 2;\n          k = ks;\n        }\n      }\n\n      k++;\n\n      switch (kase) {\n        case 1: {\n          let f = e[p - 2];\n          e[p - 2] = 0;\n          for (let j = p - 2; j >= k; j--) {\n            let t = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"hypotenuse\"])(s[j], f);\n            let cs = s[j] / t;\n            let sn = f / t;\n            s[j] = t;\n            if (j !== k) {\n              f = -sn * e[j - 1];\n              e[j - 1] = cs * e[j - 1];\n            }\n            if (wantv) {\n              for (let i = 0; i < n; i++) {\n                t = cs * V.get(i, j) + sn * V.get(i, p - 1);\n                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));\n                V.set(i, j, t);\n              }\n            }\n          }\n          break;\n        }\n        case 2: {\n          let f = e[k - 1];\n          e[k - 1] = 0;\n          for (let j = k; j < p; j++) {\n            let t = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"hypotenuse\"])(s[j], f);\n            let cs = s[j] / t;\n            let sn = f / t;\n            s[j] = t;\n            f = -sn * e[j];\n            e[j] = cs * e[j];\n            if (wantu) {\n              for (let i = 0; i < m; i++) {\n                t = cs * U.get(i, j) + sn * U.get(i, k - 1);\n                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));\n                U.set(i, j, t);\n              }\n            }\n          }\n          break;\n        }\n        case 3: {\n          const scale = Math.max(\n            Math.abs(s[p - 1]),\n            Math.abs(s[p - 2]),\n            Math.abs(e[p - 2]),\n            Math.abs(s[k]),\n            Math.abs(e[k]),\n          );\n          const sp = s[p - 1] / scale;\n          const spm1 = s[p - 2] / scale;\n          const epm1 = e[p - 2] / scale;\n          const sk = s[k] / scale;\n          const ek = e[k] / scale;\n          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\n          const c = sp * epm1 * (sp * epm1);\n          let shift = 0;\n          if (b !== 0 || c !== 0) {\n            if (b < 0) {\n              shift = 0 - Math.sqrt(b * b + c);\n            } else {\n              shift = Math.sqrt(b * b + c);\n            }\n            shift = c / (b + shift);\n          }\n          let f = (sk + sp) * (sk - sp) + shift;\n          let g = sk * ek;\n          for (let j = k; j < p - 1; j++) {\n            let t = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"hypotenuse\"])(f, g);\n            if (t === 0) t = Number.MIN_VALUE;\n            let cs = f / t;\n            let sn = g / t;\n            if (j !== k) {\n              e[j - 1] = t;\n            }\n            f = cs * s[j] + sn * e[j];\n            e[j] = cs * e[j] - sn * s[j];\n            g = sn * s[j + 1];\n            s[j + 1] = cs * s[j + 1];\n            if (wantv) {\n              for (let i = 0; i < n; i++) {\n                t = cs * V.get(i, j) + sn * V.get(i, j + 1);\n                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));\n                V.set(i, j, t);\n              }\n            }\n            t = Object(_util__WEBPACK_IMPORTED_MODULE_2__[\"hypotenuse\"])(f, g);\n            if (t === 0) t = Number.MIN_VALUE;\n            cs = f / t;\n            sn = g / t;\n            s[j] = t;\n            f = cs * e[j] + sn * s[j + 1];\n            s[j + 1] = -sn * e[j] + cs * s[j + 1];\n            g = sn * e[j + 1];\n            e[j + 1] = cs * e[j + 1];\n            if (wantu && j < m - 1) {\n              for (let i = 0; i < m; i++) {\n                t = cs * U.get(i, j) + sn * U.get(i, j + 1);\n                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));\n                U.set(i, j, t);\n              }\n            }\n          }\n          e[p - 2] = f;\n          iter = iter + 1;\n          break;\n        }\n        case 4: {\n          if (s[k] <= 0) {\n            s[k] = s[k] < 0 ? -s[k] : 0;\n            if (wantv) {\n              for (let i = 0; i <= pp; i++) {\n                V.set(i, k, -V.get(i, k));\n              }\n            }\n          }\n          while (k < pp) {\n            if (s[k] >= s[k + 1]) {\n              break;\n            }\n            let t = s[k];\n            s[k] = s[k + 1];\n            s[k + 1] = t;\n            if (wantv && k < n - 1) {\n              for (let i = 0; i < n; i++) {\n                t = V.get(i, k + 1);\n                V.set(i, k + 1, V.get(i, k));\n                V.set(i, k, t);\n              }\n            }\n            if (wantu && k < m - 1) {\n              for (let i = 0; i < m; i++) {\n                t = U.get(i, k + 1);\n                U.set(i, k + 1, U.get(i, k));\n                U.set(i, k, t);\n              }\n            }\n            k++;\n          }\n          iter = 0;\n          p--;\n          break;\n        }\n        // no default\n      }\n    }\n\n    if (swapped) {\n      let tmp = V;\n      V = U;\n      U = tmp;\n    }\n\n    this.m = m;\n    this.n = n;\n    this.s = s;\n    this.U = U;\n    this.V = V;\n  }\n\n  solve(value) {\n    let Y = value;\n    let e = this.threshold;\n    let scols = this.s.length;\n    let Ls = _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].zeros(scols, scols);\n\n    for (let i = 0; i < scols; i++) {\n      if (Math.abs(this.s[i]) <= e) {\n        Ls.set(i, i, 0);\n      } else {\n        Ls.set(i, i, 1 / this.s[i]);\n      }\n    }\n\n    let U = this.U;\n    let V = this.rightSingularVectors;\n\n    let VL = V.mmul(Ls);\n    let vrows = V.rows;\n    let urows = U.rows;\n    let VLU = _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].zeros(vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n        for (let k = 0; k < scols; k++) {\n          sum += VL.get(i, k) * U.get(j, k);\n        }\n        VLU.set(i, j, sum);\n      }\n    }\n\n    return VLU.mmul(Y);\n  }\n\n  solveForDiagonal(value) {\n    return this.solve(_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].diag(value));\n  }\n\n  inverse() {\n    let V = this.V;\n    let e = this.threshold;\n    let vrows = V.rows;\n    let vcols = V.columns;\n    let X = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](vrows, this.s.length);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < vcols; j++) {\n        if (Math.abs(this.s[j]) > e) {\n          X.set(i, j, V.get(i, j) / this.s[j]);\n        }\n      }\n    }\n\n    let U = this.U;\n\n    let urows = U.rows;\n    let ucols = U.columns;\n    let Y = new _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"](vrows, urows);\n\n    for (let i = 0; i < vrows; i++) {\n      for (let j = 0; j < urows; j++) {\n        let sum = 0;\n        for (let k = 0; k < ucols; k++) {\n          sum += X.get(i, k) * U.get(j, k);\n        }\n        Y.set(i, j, sum);\n      }\n    }\n\n    return Y;\n  }\n\n  get condition() {\n    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n  }\n\n  get norm2() {\n    return this.s[0];\n  }\n\n  get rank() {\n    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;\n    let r = 0;\n    let s = this.s;\n    for (let i = 0, ii = s.length; i < ii; i++) {\n      if (s[i] > tol) {\n        r++;\n      }\n    }\n    return r;\n  }\n\n  get diagonal() {\n    return Array.from(this.s);\n  }\n\n  get threshold() {\n    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];\n  }\n\n  get leftSingularVectors() {\n    return this.U;\n  }\n\n  get rightSingularVectors() {\n    return this.V;\n  }\n\n  get diagonalMatrix() {\n    return _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"].diag(this.s);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/dc/svd.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/util.js":
/*!***********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/util.js ***!
  \***********************************************/
/*! exports provided: hypotenuse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hypotenuse\", function() { return hypotenuse; });\nfunction hypotenuse(a, b) {\n  let r = 0;\n  if (Math.abs(a) > Math.abs(b)) {\n    r = b / a;\n    return Math.abs(a) * Math.sqrt(1 + r * r);\n  }\n  if (b !== 0) {\n    r = a / b;\n    return Math.abs(b) * Math.sqrt(1 + r * r);\n  }\n  return 0;\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/dc/util.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/decompositions.js":
/*!******************************************************!*\
  !*** ./node_modules/ml-matrix/src/decompositions.js ***!
  \******************************************************/
/*! exports provided: inverse, solve */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"solve\", function() { return solve; });\n/* harmony import */ var _dc_lu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dc/lu */ \"./node_modules/ml-matrix/src/dc/lu.js\");\n/* harmony import */ var _dc_qr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dc/qr */ \"./node_modules/ml-matrix/src/dc/qr.js\");\n/* harmony import */ var _dc_svd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dc/svd */ \"./node_modules/ml-matrix/src/dc/svd.js\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrap/WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n\n\n\n\n\n\nfunction inverse(matrix, useSVD = false) {\n  matrix = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__[\"default\"].checkMatrix(matrix);\n  if (useSVD) {\n    return new _dc_svd__WEBPACK_IMPORTED_MODULE_2__[\"default\"](matrix).inverse();\n  } else {\n    return solve(matrix, _matrix__WEBPACK_IMPORTED_MODULE_3__[\"default\"].eye(matrix.rows));\n  }\n}\n\nfunction solve(leftHandSide, rightHandSide, useSVD = false) {\n  leftHandSide = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__[\"default\"].checkMatrix(leftHandSide);\n  rightHandSide = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__[\"default\"].checkMatrix(rightHandSide);\n  if (useSVD) {\n    return new _dc_svd__WEBPACK_IMPORTED_MODULE_2__[\"default\"](leftHandSide).solve(rightHandSide);\n  } else {\n    return leftHandSide.isSquare()\n      ? new _dc_lu__WEBPACK_IMPORTED_MODULE_0__[\"default\"](leftHandSide).solve(rightHandSide)\n      : new _dc_qr__WEBPACK_IMPORTED_MODULE_1__[\"default\"](leftHandSide).solve(rightHandSide);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/decompositions.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/determinant.js":
/*!***************************************************!*\
  !*** ./node_modules/ml-matrix/src/determinant.js ***!
  \***************************************************/
/*! exports provided: determinant */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony import */ var _dc_lu__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dc/lu */ \"./node_modules/ml-matrix/src/dc/lu.js\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var _views_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./views/selection */ \"./node_modules/ml-matrix/src/views/selection.js\");\n\n\n\n\nfunction determinant(matrix) {\n  matrix = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(matrix);\n  if (matrix.isSquare()) {\n    let a, b, c, d;\n    if (matrix.columns === 2) {\n      // 2 x 2 matrix\n      a = matrix.get(0, 0);\n      b = matrix.get(0, 1);\n      c = matrix.get(1, 0);\n      d = matrix.get(1, 1);\n\n      return a * d - b * c;\n    } else if (matrix.columns === 3) {\n      // 3 x 3 matrix\n      let subMatrix0, subMatrix1, subMatrix2;\n      subMatrix0 = new _views_selection__WEBPACK_IMPORTED_MODULE_2__[\"default\"](matrix, [1, 2], [1, 2]);\n      subMatrix1 = new _views_selection__WEBPACK_IMPORTED_MODULE_2__[\"default\"](matrix, [1, 2], [0, 2]);\n      subMatrix2 = new _views_selection__WEBPACK_IMPORTED_MODULE_2__[\"default\"](matrix, [1, 2], [0, 1]);\n      a = matrix.get(0, 0);\n      b = matrix.get(0, 1);\n      c = matrix.get(0, 2);\n\n      return (\n        a * determinant(subMatrix0) -\n        b * determinant(subMatrix1) +\n        c * determinant(subMatrix2)\n      );\n    } else {\n      // general purpose determinant using the LU decomposition\n      return new _dc_lu__WEBPACK_IMPORTED_MODULE_0__[\"default\"](matrix).determinant;\n    }\n  } else {\n    throw Error('determinant can only be calculated for a square matrix');\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/determinant.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ml-matrix/src/index.js ***!
  \*********************************************/
/*! exports provided: AbstractMatrix, default, Matrix, MatrixColumnView, MatrixColumnSelectionView, MatrixFlipColumnView, MatrixFlipRowView, MatrixRowView, MatrixRowSelectionView, MatrixSelectionView, MatrixSubView, MatrixTransposeView, wrap, WrapperMatrix1D, WrapperMatrix2D, solve, inverse, determinant, linearDependencies, pseudoInverse, covariance, correlation, SingularValueDecomposition, SVD, EigenvalueDecomposition, EVD, CholeskyDecomposition, CHO, LuDecomposition, LU, QrDecomposition, QR, Nipals, NIPALS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"AbstractMatrix\", function() { return _matrix__WEBPACK_IMPORTED_MODULE_0__[\"AbstractMatrix\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Matrix\", function() { return _matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _views_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./views/index */ \"./node_modules/ml-matrix/src/views/index.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixColumnView\", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__[\"MatrixColumnView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixColumnSelectionView\", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__[\"MatrixColumnSelectionView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixFlipColumnView\", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__[\"MatrixFlipColumnView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixFlipRowView\", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__[\"MatrixFlipRowView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixRowView\", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__[\"MatrixRowView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixRowSelectionView\", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__[\"MatrixRowSelectionView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixSelectionView\", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__[\"MatrixSelectionView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixSubView\", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__[\"MatrixSubView\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixTransposeView\", function() { return _views_index__WEBPACK_IMPORTED_MODULE_1__[\"MatrixTransposeView\"]; });\n\n/* harmony import */ var _wrap_wrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./wrap/wrap */ \"./node_modules/ml-matrix/src/wrap/wrap.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"wrap\", function() { return _wrap_wrap__WEBPACK_IMPORTED_MODULE_2__[\"wrap\"]; });\n\n/* harmony import */ var _wrap_WrapperMatrix1D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wrap/WrapperMatrix1D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WrapperMatrix1D\", function() { return _wrap_WrapperMatrix1D__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./wrap/WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WrapperMatrix2D\", function() { return _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _decompositions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./decompositions */ \"./node_modules/ml-matrix/src/decompositions.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"solve\", function() { return _decompositions__WEBPACK_IMPORTED_MODULE_5__[\"solve\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return _decompositions__WEBPACK_IMPORTED_MODULE_5__[\"inverse\"]; });\n\n/* harmony import */ var _determinant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./determinant */ \"./node_modules/ml-matrix/src/determinant.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return _determinant__WEBPACK_IMPORTED_MODULE_6__[\"determinant\"]; });\n\n/* harmony import */ var _linearDependencies__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./linearDependencies */ \"./node_modules/ml-matrix/src/linearDependencies.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"linearDependencies\", function() { return _linearDependencies__WEBPACK_IMPORTED_MODULE_7__[\"linearDependencies\"]; });\n\n/* harmony import */ var _pseudoInverse__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./pseudoInverse */ \"./node_modules/ml-matrix/src/pseudoInverse.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"pseudoInverse\", function() { return _pseudoInverse__WEBPACK_IMPORTED_MODULE_8__[\"pseudoInverse\"]; });\n\n/* harmony import */ var _covariance__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./covariance */ \"./node_modules/ml-matrix/src/covariance.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"covariance\", function() { return _covariance__WEBPACK_IMPORTED_MODULE_9__[\"covariance\"]; });\n\n/* harmony import */ var _correlation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./correlation */ \"./node_modules/ml-matrix/src/correlation.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"correlation\", function() { return _correlation__WEBPACK_IMPORTED_MODULE_10__[\"correlation\"]; });\n\n/* harmony import */ var _dc_svd_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dc/svd.js */ \"./node_modules/ml-matrix/src/dc/svd.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SingularValueDecomposition\", function() { return _dc_svd_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SVD\", function() { return _dc_svd_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]; });\n\n/* harmony import */ var _dc_evd_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./dc/evd.js */ \"./node_modules/ml-matrix/src/dc/evd.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EigenvalueDecomposition\", function() { return _dc_evd_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EVD\", function() { return _dc_evd_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]; });\n\n/* harmony import */ var _dc_cholesky_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./dc/cholesky.js */ \"./node_modules/ml-matrix/src/dc/cholesky.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CholeskyDecomposition\", function() { return _dc_cholesky_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CHO\", function() { return _dc_cholesky_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]; });\n\n/* harmony import */ var _dc_lu_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./dc/lu.js */ \"./node_modules/ml-matrix/src/dc/lu.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LuDecomposition\", function() { return _dc_lu_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LU\", function() { return _dc_lu_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]; });\n\n/* harmony import */ var _dc_qr_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./dc/qr.js */ \"./node_modules/ml-matrix/src/dc/qr.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"QrDecomposition\", function() { return _dc_qr_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"QR\", function() { return _dc_qr_js__WEBPACK_IMPORTED_MODULE_15__[\"default\"]; });\n\n/* harmony import */ var _dc_nipals_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./dc/nipals.js */ \"./node_modules/ml-matrix/src/dc/nipals.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Nipals\", function() { return _dc_nipals_js__WEBPACK_IMPORTED_MODULE_16__[\"default\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NIPALS\", function() { return _dc_nipals_js__WEBPACK_IMPORTED_MODULE_16__[\"default\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/index.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/inspect.js":
/*!***********************************************!*\
  !*** ./node_modules/ml-matrix/src/inspect.js ***!
  \***********************************************/
/*! exports provided: inspectMatrix, inspectMatrixWithOptions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inspectMatrix\", function() { return inspectMatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inspectMatrixWithOptions\", function() { return inspectMatrixWithOptions; });\nconst indent = ' '.repeat(2);\nconst indentData = ' '.repeat(4);\n\nfunction inspectMatrix() {\n  return inspectMatrixWithOptions(this);\n}\n\nfunction inspectMatrixWithOptions(matrix, options = {}) {\n  const { maxRows = 15, maxColumns = 10, maxNumSize = 8 } = options;\n  return `${matrix.constructor.name} {\n${indent}[\n${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize)}\n${indent}]\n${indent}rows: ${matrix.rows}\n${indent}columns: ${matrix.columns}\n}`;\n}\n\nfunction inspectData(matrix, maxRows, maxColumns, maxNumSize) {\n  const { rows, columns } = matrix;\n  const maxI = Math.min(rows, maxRows);\n  const maxJ = Math.min(columns, maxColumns);\n  const result = [];\n  for (let i = 0; i < maxI; i++) {\n    let line = [];\n    for (let j = 0; j < maxJ; j++) {\n      line.push(formatNumber(matrix.get(i, j), maxNumSize));\n    }\n    result.push(`${line.join(' ')}`);\n  }\n  if (maxJ !== columns) {\n    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;\n  }\n  if (maxI !== rows) {\n    result.push(`... ${rows - maxRows} more rows`);\n  }\n  return result.join(`\\n${indentData}`);\n}\n\nfunction formatNumber(num, maxNumSize) {\n  const numStr = String(num);\n  if (numStr.length <= maxNumSize) {\n    return numStr.padEnd(maxNumSize, ' ');\n  }\n  const precise = num.toPrecision(maxNumSize - 2);\n  if (precise.length <= maxNumSize) {\n    return precise;\n  }\n  const exponential = num.toExponential(maxNumSize - 2);\n  const eIndex = exponential.indexOf('e');\n  const e = exponential.slice(eIndex);\n  return exponential.slice(0, maxNumSize - e.length) + e;\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/inspect.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/linearDependencies.js":
/*!**********************************************************!*\
  !*** ./node_modules/ml-matrix/src/linearDependencies.js ***!
  \**********************************************************/
/*! exports provided: linearDependencies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"linearDependencies\", function() { return linearDependencies; });\n/* harmony import */ var _dc_svd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dc/svd */ \"./node_modules/ml-matrix/src/dc/svd.js\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n\n\n\nfunction xrange(n, exception) {\n  let range = [];\n  for (let i = 0; i < n; i++) {\n    if (i !== exception) {\n      range.push(i);\n    }\n  }\n  return range;\n}\n\nfunction dependenciesOneRow(\n  error,\n  matrix,\n  index,\n  thresholdValue = 10e-10,\n  thresholdError = 10e-10,\n) {\n  if (error > thresholdError) {\n    return new Array(matrix.rows + 1).fill(0);\n  } else {\n    let returnArray = matrix.addRow(index, [0]);\n    for (let i = 0; i < returnArray.rows; i++) {\n      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {\n        returnArray.set(i, 0, 0);\n      }\n    }\n    return returnArray.to1DArray();\n  }\n}\n\nfunction linearDependencies(matrix, options = {}) {\n  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;\n  matrix = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(matrix);\n\n  let n = matrix.rows;\n  let results = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"](n, n);\n\n  for (let i = 0; i < n; i++) {\n    let b = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"].columnVector(matrix.getRow(i));\n    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();\n    let svd = new _dc_svd__WEBPACK_IMPORTED_MODULE_0__[\"default\"](Abis);\n    let x = svd.solve(b);\n    let error = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"].sub(b, Abis.mmul(x)).abs().max();\n    results.setRow(\n      i,\n      dependenciesOneRow(error, x, i, thresholdValue, thresholdError),\n    );\n  }\n  return results;\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/linearDependencies.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/mathOperations.js":
/*!******************************************************!*\
  !*** ./node_modules/ml-matrix/src/mathOperations.js ***!
  \******************************************************/
/*! exports provided: installMathOperations */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"installMathOperations\", function() { return installMathOperations; });\nfunction installMathOperations(AbstractMatrix, Matrix) {\n  AbstractMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number') return this.addS(value);\n    return this.addM(value);\n  };\n\n  AbstractMatrix.prototype.addS = function addS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.addM = function addM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.add = function add(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.add(value);\n  };\n\n  AbstractMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number') return this.subS(value);\n    return this.subM(value);\n  };\n\n  AbstractMatrix.prototype.subS = function subS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.subM = function subM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sub = function sub(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sub(value);\n  };\n  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;\n  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;\n  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;\n  AbstractMatrix.subtract = AbstractMatrix.sub;\n\n  AbstractMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number') return this.mulS(value);\n    return this.mulM(value);\n  };\n\n  AbstractMatrix.prototype.mulS = function mulS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.mulM = function mulM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mul = function mul(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mul(value);\n  };\n  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;\n  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;\n  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;\n  AbstractMatrix.multiply = AbstractMatrix.mul;\n\n  AbstractMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number') return this.divS(value);\n    return this.divM(value);\n  };\n\n  AbstractMatrix.prototype.divS = function divS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.divM = function divM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.div = function div(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.div(value);\n  };\n  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;\n  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;\n  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;\n  AbstractMatrix.divide = AbstractMatrix.div;\n\n  AbstractMatrix.prototype.mod = function mod(value) {\n    if (typeof value === 'number') return this.modS(value);\n    return this.modM(value);\n  };\n\n  AbstractMatrix.prototype.modS = function modS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.modM = function modM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mod = function mod(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mod(value);\n  };\n  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;\n  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;\n  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;\n  AbstractMatrix.modulus = AbstractMatrix.mod;\n\n  AbstractMatrix.prototype.and = function and(value) {\n    if (typeof value === 'number') return this.andS(value);\n    return this.andM(value);\n  };\n\n  AbstractMatrix.prototype.andS = function andS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.andM = function andM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.and = function and(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.and(value);\n  };\n\n  AbstractMatrix.prototype.or = function or(value) {\n    if (typeof value === 'number') return this.orS(value);\n    return this.orM(value);\n  };\n\n  AbstractMatrix.prototype.orS = function orS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.orM = function orM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.or = function or(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.or(value);\n  };\n\n  AbstractMatrix.prototype.xor = function xor(value) {\n    if (typeof value === 'number') return this.xorS(value);\n    return this.xorM(value);\n  };\n\n  AbstractMatrix.prototype.xorS = function xorS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.xorM = function xorM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.xor = function xor(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.xor(value);\n  };\n\n  AbstractMatrix.prototype.leftShift = function leftShift(value) {\n    if (typeof value === 'number') return this.leftShiftS(value);\n    return this.leftShiftM(value);\n  };\n\n  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.leftShift = function leftShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.leftShift(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {\n    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);\n    return this.signPropagatingRightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.signPropagatingRightShift(value);\n  };\n\n  AbstractMatrix.prototype.rightShift = function rightShift(value) {\n    if (typeof value === 'number') return this.rightShiftS(value);\n    return this.rightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.rightShift = function rightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.rightShift(value);\n  };\n  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;\n  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;\n  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;\n  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;\n\n  AbstractMatrix.prototype.not = function not() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, ~(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.not = function not(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.not();\n  };\n\n  AbstractMatrix.prototype.abs = function abs() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.abs(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.abs = function abs(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.abs();\n  };\n\n  AbstractMatrix.prototype.acos = function acos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acos = function acos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acos();\n  };\n\n  AbstractMatrix.prototype.acosh = function acosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acosh = function acosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acosh();\n  };\n\n  AbstractMatrix.prototype.asin = function asin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asin = function asin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asin();\n  };\n\n  AbstractMatrix.prototype.asinh = function asinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asinh = function asinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asinh();\n  };\n\n  AbstractMatrix.prototype.atan = function atan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atan = function atan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atan();\n  };\n\n  AbstractMatrix.prototype.atanh = function atanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atanh = function atanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atanh();\n  };\n\n  AbstractMatrix.prototype.cbrt = function cbrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cbrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cbrt = function cbrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cbrt();\n  };\n\n  AbstractMatrix.prototype.ceil = function ceil() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.ceil(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.ceil = function ceil(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.ceil();\n  };\n\n  AbstractMatrix.prototype.clz32 = function clz32() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.clz32(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.clz32 = function clz32(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.clz32();\n  };\n\n  AbstractMatrix.prototype.cos = function cos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cos = function cos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cos();\n  };\n\n  AbstractMatrix.prototype.cosh = function cosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cosh = function cosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cosh();\n  };\n\n  AbstractMatrix.prototype.exp = function exp() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.exp(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.exp = function exp(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.exp();\n  };\n\n  AbstractMatrix.prototype.expm1 = function expm1() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.expm1(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.expm1 = function expm1(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.expm1();\n  };\n\n  AbstractMatrix.prototype.floor = function floor() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.floor(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.floor = function floor(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.floor();\n  };\n\n  AbstractMatrix.prototype.fround = function fround() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.fround(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.fround = function fround(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.fround();\n  };\n\n  AbstractMatrix.prototype.log = function log() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log = function log(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log();\n  };\n\n  AbstractMatrix.prototype.log1p = function log1p() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log1p(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log1p = function log1p(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log1p();\n  };\n\n  AbstractMatrix.prototype.log10 = function log10() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log10(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log10 = function log10(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log10();\n  };\n\n  AbstractMatrix.prototype.log2 = function log2() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log2(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log2 = function log2(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log2();\n  };\n\n  AbstractMatrix.prototype.round = function round() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.round(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.round = function round(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.round();\n  };\n\n  AbstractMatrix.prototype.sign = function sign() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sign(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sign = function sign(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sign();\n  };\n\n  AbstractMatrix.prototype.sin = function sin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sin = function sin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sin();\n  };\n\n  AbstractMatrix.prototype.sinh = function sinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sinh = function sinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sinh();\n  };\n\n  AbstractMatrix.prototype.sqrt = function sqrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sqrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sqrt = function sqrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sqrt();\n  };\n\n  AbstractMatrix.prototype.tan = function tan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tan = function tan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tan();\n  };\n\n  AbstractMatrix.prototype.tanh = function tanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tanh = function tanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tanh();\n  };\n\n  AbstractMatrix.prototype.trunc = function trunc() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.trunc(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.trunc = function trunc(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.trunc();\n  };\n\n  AbstractMatrix.pow = function pow(matrix, arg0) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.pow(arg0);\n  };\n\n  AbstractMatrix.prototype.pow = function pow(value) {\n    if (typeof value === 'number') return this.powS(value);\n    return this.powM(value);\n  };\n\n  AbstractMatrix.prototype.powS = function powS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), value));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.powM = function powM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));\n      }\n    }\n    return this;\n  };\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/mathOperations.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/matrix.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/matrix.js ***!
  \**********************************************/
/*! exports provided: AbstractMatrix, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AbstractMatrix\", function() { return AbstractMatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Matrix; });\n/* harmony import */ var ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ml-array-rescale */ \"./node_modules/ml-array-rescale/lib-es6/index.js\");\n/* harmony import */ var _inspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inspect */ \"./node_modules/ml-matrix/src/inspect.js\");\n/* harmony import */ var _mathOperations__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mathOperations */ \"./node_modules/ml-matrix/src/mathOperations.js\");\n/* harmony import */ var _stat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./stat */ \"./node_modules/ml-matrix/src/stat.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util */ \"./node_modules/ml-matrix/src/util.js\");\n\n\n\n\n\n\n\nclass AbstractMatrix {\n  static from1DArray(newRows, newColumns, newData) {\n    let length = newRows * newColumns;\n    if (length !== newData.length) {\n      throw new RangeError('data length does not match given dimensions');\n    }\n    let newMatrix = new Matrix(newRows, newColumns);\n    for (let row = 0; row < newRows; row++) {\n      for (let column = 0; column < newColumns; column++) {\n        newMatrix.set(row, column, newData[row * newColumns + column]);\n      }\n    }\n    return newMatrix;\n  }\n\n  static rowVector(newData) {\n    let vector = new Matrix(1, newData.length);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(0, i, newData[i]);\n    }\n    return vector;\n  }\n\n  static columnVector(newData) {\n    let vector = new Matrix(newData.length, 1);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(i, 0, newData[i]);\n    }\n    return vector;\n  }\n\n  static zeros(rows, columns) {\n    return new Matrix(rows, columns);\n  }\n\n  static ones(rows, columns) {\n    return new Matrix(rows, columns).fill(1);\n  }\n\n  static rand(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { random = Math.random } = options;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.set(i, j, random());\n      }\n    }\n    return matrix;\n  }\n\n  static randInt(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1000, random = Math.random } = options;\n    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');\n    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let interval = max - min;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        let value = min + Math.round(random() * interval);\n        matrix.set(i, j, value);\n      }\n    }\n    return matrix;\n  }\n\n  static eye(rows, columns, value) {\n    if (columns === undefined) columns = rows;\n    if (value === undefined) value = 1;\n    let min = Math.min(rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, value);\n    }\n    return matrix;\n  }\n\n  static diag(data, rows, columns) {\n    let l = data.length;\n    if (rows === undefined) rows = l;\n    if (columns === undefined) columns = rows;\n    let min = Math.min(l, rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, data[i]);\n    }\n    return matrix;\n  }\n\n  static min(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static max(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new this(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static checkMatrix(value) {\n    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);\n  }\n\n  static isMatrix(value) {\n    return value != null && value.klass === 'Matrix';\n  }\n\n  get size() {\n    return this.rows * this.columns;\n  }\n\n  apply(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        callback.call(this, i, j);\n      }\n    }\n    return this;\n  }\n\n  to1DArray() {\n    let array = [];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        array.push(this.get(i, j));\n      }\n    }\n    return array;\n  }\n\n  to2DArray() {\n    let copy = [];\n    for (let i = 0; i < this.rows; i++) {\n      copy.push([]);\n      for (let j = 0; j < this.columns; j++) {\n        copy[i].push(this.get(i, j));\n      }\n    }\n    return copy;\n  }\n\n  toJSON() {\n    return this.to2DArray();\n  }\n\n  isRowVector() {\n    return this.rows === 1;\n  }\n\n  isColumnVector() {\n    return this.columns === 1;\n  }\n\n  isVector() {\n    return this.rows === 1 || this.columns === 1;\n  }\n\n  isSquare() {\n    return this.rows === this.columns;\n  }\n\n  isSymmetric() {\n    if (this.isSquare()) {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          if (this.get(i, j) !== this.get(j, i)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  isEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isEchelonForm = false;\n          checked = true;\n        }\n      }\n      i++;\n    }\n    return isEchelonForm;\n  }\n\n  isReducedEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isReducedEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isReducedEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isReducedEchelonForm = false;\n          checked = true;\n        }\n      }\n      for (let k = j + 1; k < this.rows; k++) {\n        if (this.get(i, k) !== 0) {\n          isReducedEchelonForm = false;\n        }\n      }\n      i++;\n    }\n    return isReducedEchelonForm;\n  }\n\n  echelonForm() {\n    let result = this.clone();\n    let h = 0;\n    let k = 0;\n    while (h < result.rows && k < result.columns) {\n      let iMax = h;\n      for (let i = h; i < result.rows; i++) {\n        if (result.get(i, k) > result.get(iMax, k)) {\n          iMax = i;\n        }\n      }\n      if (result.get(iMax, k) === 0) {\n        k++;\n      } else {\n        result.swapRows(h, iMax);\n        let tmp = result.get(h, k);\n        for (let j = k; j < result.columns; j++) {\n          result.set(h, j, result.get(h, j) / tmp);\n        }\n        for (let i = h + 1; i < result.rows; i++) {\n          let factor = result.get(i, k) / result.get(h, k);\n          result.set(i, k, 0);\n          for (let j = k + 1; j < result.columns; j++) {\n            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);\n          }\n        }\n        h++;\n        k++;\n      }\n    }\n    return result;\n  }\n\n  reducedEchelonForm() {\n    let result = this.echelonForm();\n    let m = result.columns;\n    let n = result.rows;\n    let h = n - 1;\n    while (h >= 0) {\n      if (result.maxRow(h) === 0) {\n        h--;\n      } else {\n        let p = 0;\n        let pivot = false;\n        while (p < n && pivot === false) {\n          if (result.get(h, p) === 1) {\n            pivot = true;\n          } else {\n            p++;\n          }\n        }\n        for (let i = 0; i < h; i++) {\n          let factor = result.get(i, p);\n          for (let j = p; j < m; j++) {\n            let tmp = result.get(i, j) - factor * result.get(h, j);\n            result.set(i, j, tmp);\n          }\n        }\n        h--;\n      }\n    }\n    return result;\n  }\n\n  set() {\n    throw new Error('set method is unimplemented');\n  }\n\n  get() {\n    throw new Error('get method is unimplemented');\n  }\n\n  repeat(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { rows = 1, columns = 1 } = options;\n    if (!Number.isInteger(rows) || rows <= 0) {\n      throw new TypeError('rows must be a positive integer');\n    }\n    if (!Number.isInteger(columns) || columns <= 0) {\n      throw new TypeError('columns must be a positive integer');\n    }\n    let matrix = new Matrix(this.rows * rows, this.columns * columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n      }\n    }\n    return matrix;\n  }\n\n  fill(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, value);\n      }\n    }\n    return this;\n  }\n\n  neg() {\n    return this.mulS(-1);\n  }\n\n  getRow(index) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, index);\n    let row = [];\n    for (let i = 0; i < this.columns; i++) {\n      row.push(this.get(index, i));\n    }\n    return row;\n  }\n\n  getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n  }\n\n  setRow(index, array) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, index);\n    array = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowVector\"])(this, array);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, array[i]);\n    }\n    return this;\n  }\n\n  swapRows(row1, row2) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, row1);\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, row2);\n    for (let i = 0; i < this.columns; i++) {\n      let temp = this.get(row1, i);\n      this.set(row1, i, this.get(row2, i));\n      this.set(row2, i, temp);\n    }\n    return this;\n  }\n\n  getColumn(index) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, index);\n    let column = [];\n    for (let i = 0; i < this.rows; i++) {\n      column.push(this.get(i, index));\n    }\n    return column;\n  }\n\n  getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n  }\n\n  setColumn(index, array) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, index);\n    array = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnVector\"])(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, array[i]);\n    }\n    return this;\n  }\n\n  swapColumns(column1, column2) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, column1);\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, column2);\n    for (let i = 0; i < this.rows; i++) {\n      let temp = this.get(i, column1);\n      this.set(i, column1, this.get(i, column2));\n      this.set(i, column2, temp);\n    }\n    return this;\n  }\n\n  addRowVector(vector) {\n    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowVector\"])(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[j]);\n      }\n    }\n    return this;\n  }\n\n  subRowVector(vector) {\n    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowVector\"])(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[j]);\n      }\n    }\n    return this;\n  }\n\n  mulRowVector(vector) {\n    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowVector\"])(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[j]);\n      }\n    }\n    return this;\n  }\n\n  divRowVector(vector) {\n    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowVector\"])(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[j]);\n      }\n    }\n    return this;\n  }\n\n  addColumnVector(vector) {\n    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnVector\"])(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[i]);\n      }\n    }\n    return this;\n  }\n\n  subColumnVector(vector) {\n    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnVector\"])(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulColumnVector(vector) {\n    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnVector\"])(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[i]);\n      }\n    }\n    return this;\n  }\n\n  divColumnVector(vector) {\n    vector = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnVector\"])(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulRow(index, value) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, index);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, this.get(index, i) * value);\n    }\n    return this;\n  }\n\n  mulColumn(index, value) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, this.get(i, index) * value);\n    }\n    return this;\n  }\n\n  max() {\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  maxIndex() {\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  min() {\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  minIndex() {\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  maxRow(row) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, row);\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  maxRowIndex(row) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, row);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  minRow(row) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, row);\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  minRowIndex(row) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, row);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  maxColumn(column) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, column);\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  maxColumnIndex(column) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, column);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  minColumn(column) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, column);\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  minColumnIndex(column) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, column);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  diag() {\n    let min = Math.min(this.rows, this.columns);\n    let diag = [];\n    for (let i = 0; i < min; i++) {\n      diag.push(this.get(i, i));\n    }\n    return diag;\n  }\n\n  norm(type = 'frobenius') {\n    let result = 0;\n    if (type === 'max') {\n      return this.max();\n    } else if (type === 'frobenius') {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j < this.columns; j++) {\n          result = result + this.get(i, j) * this.get(i, j);\n        }\n      }\n      return Math.sqrt(result);\n    } else {\n      throw new RangeError(`unknown norm type: ${type}`);\n    }\n  }\n\n  cumulativeSum() {\n    let sum = 0;\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        sum += this.get(i, j);\n        this.set(i, j, sum);\n      }\n    }\n    return this;\n  }\n\n  dot(vector2) {\n    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n    let vector1 = this.to1DArray();\n    if (vector1.length !== vector2.length) {\n      throw new RangeError('vectors do not have the same size');\n    }\n    let dot = 0;\n    for (let i = 0; i < vector1.length; i++) {\n      dot += vector1[i] * vector2[i];\n    }\n    return dot;\n  }\n\n  mmul(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.columns;\n\n    let result = new Matrix(m, p);\n\n    let Bcolj = new Float64Array(n);\n    for (let j = 0; j < p; j++) {\n      for (let k = 0; k < n; k++) {\n        Bcolj[k] = other.get(k, j);\n      }\n\n      for (let i = 0; i < m; i++) {\n        let s = 0;\n        for (let k = 0; k < n; k++) {\n          s += this.get(i, k) * Bcolj[k];\n        }\n\n        result.set(i, j, s);\n      }\n    }\n    return result;\n  }\n\n  strassen2x2(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(2, 2);\n    const a11 = this.get(0, 0);\n    const b11 = other.get(0, 0);\n    const a12 = this.get(0, 1);\n    const b12 = other.get(0, 1);\n    const a21 = this.get(1, 0);\n    const b21 = other.get(1, 0);\n    const a22 = this.get(1, 1);\n    const b22 = other.get(1, 1);\n\n    // Compute intermediate values.\n    const m1 = (a11 + a22) * (b11 + b22);\n    const m2 = (a21 + a22) * b11;\n    const m3 = a11 * (b12 - b22);\n    const m4 = a22 * (b21 - b11);\n    const m5 = (a11 + a12) * b22;\n    const m6 = (a21 - a11) * (b11 + b12);\n    const m7 = (a12 - a22) * (b21 + b22);\n\n    // Combine intermediate values into the output.\n    const c00 = m1 + m4 - m5 + m7;\n    const c01 = m3 + m5;\n    const c10 = m2 + m4;\n    const c11 = m1 - m2 + m3 + m6;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    return result;\n  }\n\n  strassen3x3(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(3, 3);\n\n    const a00 = this.get(0, 0);\n    const a01 = this.get(0, 1);\n    const a02 = this.get(0, 2);\n    const a10 = this.get(1, 0);\n    const a11 = this.get(1, 1);\n    const a12 = this.get(1, 2);\n    const a20 = this.get(2, 0);\n    const a21 = this.get(2, 1);\n    const a22 = this.get(2, 2);\n\n    const b00 = other.get(0, 0);\n    const b01 = other.get(0, 1);\n    const b02 = other.get(0, 2);\n    const b10 = other.get(1, 0);\n    const b11 = other.get(1, 1);\n    const b12 = other.get(1, 2);\n    const b20 = other.get(2, 0);\n    const b21 = other.get(2, 1);\n    const b22 = other.get(2, 2);\n\n    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n    const m2 = (a00 - a10) * (-b01 + b11);\n    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n    const m5 = (a10 + a11) * (-b00 + b01);\n    const m6 = a00 * b00;\n    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n    const m8 = (-a00 + a20) * (b02 - b12);\n    const m9 = (a20 + a21) * (-b00 + b02);\n    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n    const m13 = (a02 - a22) * (b11 - b21);\n    const m14 = a02 * b20;\n    const m15 = (a21 + a22) * (-b20 + b21);\n    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n    const m17 = (a02 - a12) * (b12 - b22);\n    const m18 = (a11 + a12) * (-b20 + b22);\n    const m19 = a01 * b10;\n    const m20 = a12 * b21;\n    const m21 = a10 * b02;\n    const m22 = a20 * b01;\n    const m23 = a22 * b22;\n\n    const c00 = m6 + m14 + m19;\n    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n    const c11 = m2 + m4 + m5 + m6 + m20;\n    const c12 = m14 + m16 + m17 + m18 + m21;\n    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n    const c21 = m12 + m13 + m14 + m15 + m22;\n    const c22 = m6 + m7 + m8 + m9 + m23;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(0, 2, c02);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    result.set(1, 2, c12);\n    result.set(2, 0, c20);\n    result.set(2, 1, c21);\n    result.set(2, 2, c22);\n    return result;\n  }\n\n  mmulStrassen(y) {\n    y = Matrix.checkMatrix(y);\n    let x = this.clone();\n    let r1 = x.rows;\n    let c1 = x.columns;\n    let r2 = y.rows;\n    let c2 = y.columns;\n    if (c1 !== r2) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,\n      );\n    }\n\n    // Put a matrix into the top left of a matrix of zeros.\n    // `rows` and `cols` are the dimensions of the output matrix.\n    function embed(mat, rows, cols) {\n      let r = mat.rows;\n      let c = mat.columns;\n      if (r === rows && c === cols) {\n        return mat;\n      } else {\n        let resultat = AbstractMatrix.zeros(rows, cols);\n        resultat = resultat.setSubMatrix(mat, 0, 0);\n        return resultat;\n      }\n    }\n\n    // Make sure both matrices are the same size.\n    // This is exclusively for simplicity:\n    // this algorithm can be implemented with matrices of different sizes.\n\n    let r = Math.max(r1, r2);\n    let c = Math.max(c1, c2);\n    x = embed(x, r, c);\n    y = embed(y, r, c);\n\n    // Our recursive multiplication function.\n    function blockMult(a, b, rows, cols) {\n      // For small matrices, resort to naive multiplication.\n      if (rows <= 512 || cols <= 512) {\n        return a.mmul(b); // a is equivalent to this\n      }\n\n      // Apply dynamic padding.\n      if (rows % 2 === 1 && cols % 2 === 1) {\n        a = embed(a, rows + 1, cols + 1);\n        b = embed(b, rows + 1, cols + 1);\n      } else if (rows % 2 === 1) {\n        a = embed(a, rows + 1, cols);\n        b = embed(b, rows + 1, cols);\n      } else if (cols % 2 === 1) {\n        a = embed(a, rows, cols + 1);\n        b = embed(b, rows, cols + 1);\n      }\n\n      let halfRows = parseInt(a.rows / 2, 10);\n      let halfCols = parseInt(a.columns / 2, 10);\n      // Subdivide input matrices.\n      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n      // Compute intermediate values.\n      let m1 = blockMult(\n        AbstractMatrix.add(a11, a22),\n        AbstractMatrix.add(b11, b22),\n        halfRows,\n        halfCols,\n      );\n      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);\n      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);\n      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);\n      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);\n      let m6 = blockMult(\n        AbstractMatrix.sub(a21, a11),\n        AbstractMatrix.add(b11, b12),\n        halfRows,\n        halfCols,\n      );\n      let m7 = blockMult(\n        AbstractMatrix.sub(a12, a22),\n        AbstractMatrix.add(b21, b22),\n        halfRows,\n        halfCols,\n      );\n\n      // Combine intermediate values into the output.\n      let c11 = AbstractMatrix.add(m1, m4);\n      c11.sub(m5);\n      c11.add(m7);\n      let c12 = AbstractMatrix.add(m3, m5);\n      let c21 = AbstractMatrix.add(m2, m4);\n      let c22 = AbstractMatrix.sub(m1, m2);\n      c22.add(m3);\n      c22.add(m6);\n\n      // Crop output to the desired size (undo dynamic padding).\n      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);\n      resultat = resultat.setSubMatrix(c11, 0, 0);\n      resultat = resultat.setSubMatrix(c12, c11.rows, 0);\n      resultat = resultat.setSubMatrix(c21, 0, c11.columns);\n      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\n      return resultat.subMatrix(0, rows - 1, 0, cols - 1);\n    }\n    return blockMult(x, y, r, c);\n  }\n\n  scaleRows(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.rows; i++) {\n      const row = this.getRow(i);\n      Object(ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(row, { min, max, output: row });\n      newMatrix.setRow(i, row);\n    }\n    return newMatrix;\n  }\n\n  scaleColumns(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.columns; i++) {\n      const column = this.getColumn(i);\n      Object(ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(column, {\n        min: min,\n        max: max,\n        output: column,\n      });\n      newMatrix.setColumn(i, column);\n    }\n    return newMatrix;\n  }\n\n  flipRows() {\n    const middle = Math.ceil(this.columns / 2);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < middle; j++) {\n        let first = this.get(i, j);\n        let last = this.get(i, this.columns - 1 - j);\n        this.set(i, j, last);\n        this.set(i, this.columns - 1 - j, first);\n      }\n    }\n    return this;\n  }\n\n  flipColumns() {\n    const middle = Math.ceil(this.rows / 2);\n    for (let j = 0; j < this.columns; j++) {\n      for (let i = 0; i < middle; i++) {\n        let first = this.get(i, j);\n        let last = this.get(this.rows - 1 - i, j);\n        this.set(i, j, last);\n        this.set(this.rows - 1 - i, j, first);\n      }\n    }\n    return this;\n  }\n\n  kroneckerProduct(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.rows;\n    let q = other.columns;\n\n    let result = new Matrix(m * p, n * q);\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        for (let k = 0; k < p; k++) {\n          for (let l = 0; l < q; l++) {\n            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  transpose() {\n    let result = new Matrix(this.columns, this.rows);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        result.set(j, i, this.get(i, j));\n      }\n    }\n    return result;\n  }\n\n  sortRows(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.rows; i++) {\n      this.setRow(i, this.getRow(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  sortColumns(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.columns; i++) {\n      this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  subMatrix(startRow, endRow, startColumn, endColumn) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRange\"])(this, startRow, endRow, startColumn, endColumn);\n    let newMatrix = new Matrix(\n      endRow - startRow + 1,\n      endColumn - startColumn + 1,\n    );\n    for (let i = startRow; i <= endRow; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixRow(indices, startColumn, endColumn) {\n    if (startColumn === undefined) startColumn = 0;\n    if (endColumn === undefined) endColumn = this.columns - 1;\n    if (\n      startColumn > endColumn ||\n      startColumn < 0 ||\n      startColumn >= this.columns ||\n      endColumn < 0 ||\n      endColumn >= this.columns\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        if (indices[i] < 0 || indices[i] >= this.rows) {\n          throw new RangeError(`Row index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixColumn(indices, startRow, endRow) {\n    if (startRow === undefined) startRow = 0;\n    if (endRow === undefined) endRow = this.rows - 1;\n    if (\n      startRow > endRow ||\n      startRow < 0 ||\n      startRow >= this.rows ||\n      endRow < 0 ||\n      endRow >= this.rows\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startRow; j <= endRow; j++) {\n        if (indices[i] < 0 || indices[i] >= this.columns) {\n          throw new RangeError(`Column index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n      }\n    }\n    return newMatrix;\n  }\n\n  setSubMatrix(matrix, startRow, startColumn) {\n    matrix = Matrix.checkMatrix(matrix);\n    let endRow = startRow + matrix.rows - 1;\n    let endColumn = startColumn + matrix.columns - 1;\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRange\"])(this, startRow, endRow, startColumn, endColumn);\n    for (let i = 0; i < matrix.rows; i++) {\n      for (let j = 0; j < matrix.columns; j++) {\n        this.set(startRow + i, startColumn + j, matrix.get(i, j));\n      }\n    }\n    return this;\n  }\n\n  selection(rowIndices, columnIndices) {\n    let indices = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkIndices\"])(this, rowIndices, columnIndices);\n    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);\n    for (let i = 0; i < indices.row.length; i++) {\n      let rowIndex = indices.row[i];\n      for (let j = 0; j < indices.column.length; j++) {\n        let columnIndex = indices.column[j];\n        newMatrix.set(i, j, this.get(rowIndex, columnIndex));\n      }\n    }\n    return newMatrix;\n  }\n\n  trace() {\n    let min = Math.min(this.rows, this.columns);\n    let trace = 0;\n    for (let i = 0; i < min; i++) {\n      trace += this.get(i, i);\n    }\n    return trace;\n  }\n\n  clone() {\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let row = 0; row < this.rows; row++) {\n      for (let column = 0; column < this.columns; column++) {\n        newMatrix.set(row, column, this.get(row, column));\n      }\n    }\n    return newMatrix;\n  }\n\n  sum(by) {\n    switch (by) {\n      case 'row':\n        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"sumByRow\"])(this);\n      case 'column':\n        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"sumByColumn\"])(this);\n      case undefined:\n        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"sumAll\"])(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  product(by) {\n    switch (by) {\n      case 'row':\n        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"productByRow\"])(this);\n      case 'column':\n        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"productByColumn\"])(this);\n      case undefined:\n        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"productAll\"])(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  mean(by) {\n    const sum = this.sum(by);\n    switch (by) {\n      case 'row': {\n        for (let i = 0; i < this.rows; i++) {\n          sum[i] /= this.columns;\n        }\n        return sum;\n      }\n      case 'column': {\n        for (let i = 0; i < this.columns; i++) {\n          sum[i] /= this.rows;\n        }\n        return sum;\n      }\n      case undefined:\n        return sum / this.size;\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  variance(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { unbiased = true, mean = this.mean(by) } = options;\n    if (typeof unbiased !== 'boolean') {\n      throw new TypeError('unbiased must be a boolean');\n    }\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"varianceByRow\"])(this, unbiased, mean);\n      }\n      case 'column': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"varianceByColumn\"])(this, unbiased, mean);\n      }\n      case undefined: {\n        if (typeof mean !== 'number') {\n          throw new TypeError('mean must be a number');\n        }\n        return Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"varianceAll\"])(this, unbiased, mean);\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  standardDeviation(by, options) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    const variance = this.variance(by, options);\n    if (by === undefined) {\n      return Math.sqrt(variance);\n    } else {\n      for (let i = 0; i < variance.length; i++) {\n        variance[i] = Math.sqrt(variance[i]);\n      }\n      return variance;\n    }\n  }\n\n  center(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { center = this.mean(by) } = options;\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"centerByRow\"])(this, center);\n        return this;\n      }\n      case 'column': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"centerByColumn\"])(this, center);\n        return this;\n      }\n      case undefined: {\n        if (typeof center !== 'number') {\n          throw new TypeError('center must be a number');\n        }\n        Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"centerAll\"])(this, center);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  scale(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    let scale = options.scale;\n    switch (by) {\n      case 'row': {\n        if (scale === undefined) {\n          scale = Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"getScaleByRow\"])(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"scaleByRow\"])(this, scale);\n        return this;\n      }\n      case 'column': {\n        if (scale === undefined) {\n          scale = Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"getScaleByColumn\"])(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"scaleByColumn\"])(this, scale);\n        return this;\n      }\n      case undefined: {\n        if (scale === undefined) {\n          scale = Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"getScaleAll\"])(this);\n        } else if (typeof scale !== 'number') {\n          throw new TypeError('scale must be a number');\n        }\n        Object(_stat__WEBPACK_IMPORTED_MODULE_3__[\"scaleAll\"])(this, scale);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  toString(options) {\n    return Object(_inspect__WEBPACK_IMPORTED_MODULE_1__[\"inspectMatrixWithOptions\"])(this, options);\n  }\n}\n\nAbstractMatrix.prototype.klass = 'Matrix';\nif (typeof Symbol !== 'undefined') {\n  AbstractMatrix.prototype[\n    Symbol.for('nodejs.util.inspect.custom')\n  ] = _inspect__WEBPACK_IMPORTED_MODULE_1__[\"inspectMatrix\"];\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\n// Synonyms\nAbstractMatrix.random = AbstractMatrix.rand;\nAbstractMatrix.randomInt = AbstractMatrix.randInt;\nAbstractMatrix.diagonal = AbstractMatrix.diag;\nAbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;\nAbstractMatrix.identity = AbstractMatrix.eye;\nAbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;\nAbstractMatrix.prototype.tensorProduct =\n  AbstractMatrix.prototype.kroneckerProduct;\n\nclass Matrix extends AbstractMatrix {\n  constructor(nRows, nColumns) {\n    super();\n    if (Matrix.isMatrix(nRows)) {\n      return nRows.clone();\n    } else if (Number.isInteger(nRows) && nRows > 0) {\n      // Create an empty matrix\n      this.data = [];\n      if (Number.isInteger(nColumns) && nColumns > 0) {\n        for (let i = 0; i < nRows; i++) {\n          this.data.push(new Float64Array(nColumns));\n        }\n      } else {\n        throw new TypeError('nColumns must be a positive integer');\n      }\n    } else if (Array.isArray(nRows)) {\n      // Copy the values from the 2D array\n      const arrayData = nRows;\n      nRows = arrayData.length;\n      nColumns = arrayData[0].length;\n      if (typeof nColumns !== 'number' || nColumns === 0) {\n        throw new TypeError(\n          'Data must be a 2D array with at least one element',\n        );\n      }\n      this.data = [];\n      for (let i = 0; i < nRows; i++) {\n        if (arrayData[i].length !== nColumns) {\n          throw new RangeError('Inconsistent array dimensions');\n        }\n        this.data.push(Float64Array.from(arrayData[i]));\n      }\n    } else {\n      throw new TypeError(\n        'First argument must be a positive number or an array',\n      );\n    }\n    this.rows = nRows;\n    this.columns = nColumns;\n    return this;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n\n  removeRow(index) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, index);\n    if (this.rows === 1) {\n      throw new RangeError('A matrix cannot have less than one row');\n    }\n    this.data.splice(index, 1);\n    this.rows -= 1;\n    return this;\n  }\n\n  addRow(index, array) {\n    if (array === undefined) {\n      array = index;\n      index = this.rows;\n    }\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowIndex\"])(this, index, true);\n    array = Float64Array.from(Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkRowVector\"])(this, array, true));\n    this.data.splice(index, 0, array);\n    this.rows += 1;\n    return this;\n  }\n\n  removeColumn(index) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, index);\n    if (this.columns === 1) {\n      throw new RangeError('A matrix cannot have less than one column');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns - 1);\n      for (let j = 0; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      for (let j = index + 1; j < this.columns; j++) {\n        newRow[j - 1] = this.data[i][j];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns -= 1;\n    return this;\n  }\n\n  addColumn(index, array) {\n    if (typeof array === 'undefined') {\n      array = index;\n      index = this.columns;\n    }\n    Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnIndex\"])(this, index, true);\n    array = Object(_util__WEBPACK_IMPORTED_MODULE_4__[\"checkColumnVector\"])(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns + 1);\n      let j = 0;\n      for (; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      newRow[j++] = array[i];\n      for (; j < this.columns + 1; j++) {\n        newRow[j] = this.data[i][j - 1];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns += 1;\n    return this;\n  }\n}\n\nObject(_mathOperations__WEBPACK_IMPORTED_MODULE_2__[\"installMathOperations\"])(AbstractMatrix, Matrix);\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/matrix.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/pseudoInverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/ml-matrix/src/pseudoInverse.js ***!
  \*****************************************************/
/*! exports provided: pseudoInverse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pseudoInverse\", function() { return pseudoInverse; });\n/* harmony import */ var _dc_svd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dc/svd */ \"./node_modules/ml-matrix/src/dc/svd.js\");\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n\n\n\nfunction pseudoInverse(matrix, threshold = Number.EPSILON) {\n  matrix = _matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"].checkMatrix(matrix);\n  let svdSolution = new _dc_svd__WEBPACK_IMPORTED_MODULE_0__[\"default\"](matrix, { autoTranspose: true });\n\n  let U = svdSolution.leftSingularVectors;\n  let V = svdSolution.rightSingularVectors;\n  let s = svdSolution.diagonal;\n\n  for (let i = 0; i < s.length; i++) {\n    if (Math.abs(s[i]) > threshold) {\n      s[i] = 1.0 / s[i];\n    } else {\n      s[i] = 0.0;\n    }\n  }\n\n  return V.mmul(_matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"].diag(s).mmul(U.transpose()));\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/pseudoInverse.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/stat.js":
/*!********************************************!*\
  !*** ./node_modules/ml-matrix/src/stat.js ***!
  \********************************************/
/*! exports provided: sumByRow, sumByColumn, sumAll, productByRow, productByColumn, productAll, varianceByRow, varianceByColumn, varianceAll, centerByRow, centerByColumn, centerAll, getScaleByRow, scaleByRow, getScaleByColumn, scaleByColumn, getScaleAll, scaleAll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sumByRow\", function() { return sumByRow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sumByColumn\", function() { return sumByColumn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sumAll\", function() { return sumAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"productByRow\", function() { return productByRow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"productByColumn\", function() { return productByColumn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"productAll\", function() { return productAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"varianceByRow\", function() { return varianceByRow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"varianceByColumn\", function() { return varianceByColumn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"varianceAll\", function() { return varianceAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"centerByRow\", function() { return centerByRow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"centerByColumn\", function() { return centerByColumn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"centerAll\", function() { return centerAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScaleByRow\", function() { return getScaleByRow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleByRow\", function() { return scaleByRow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScaleByColumn\", function() { return getScaleByColumn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleByColumn\", function() { return scaleByColumn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScaleAll\", function() { return getScaleAll; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAll\", function() { return scaleAll; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./node_modules/ml-matrix/src/util.js\");\n\n\nfunction sumByRow(matrix) {\n  let sum = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"newArray\"])(matrix.rows);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction sumByColumn(matrix) {\n  let sum = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"newArray\"])(matrix.columns);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction sumAll(matrix) {\n  let v = 0;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v += matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nfunction productByRow(matrix) {\n  let sum = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"newArray\"])(matrix.rows, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction productByColumn(matrix) {\n  let sum = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"newArray\"])(matrix.columns, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction productAll(matrix) {\n  let v = 1;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v *= matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nfunction varianceByRow(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let i = 0; i < rows; i++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean[i];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / cols) / cols);\n    }\n  }\n  return variance;\n}\n\nfunction varianceByColumn(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let j = 0; j < cols; j++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let i = 0; i < rows; i++) {\n      x = matrix.get(i, j) - mean[j];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / rows) / rows);\n    }\n  }\n  return variance;\n}\n\nfunction varianceAll(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const size = rows * cols;\n\n  let sum1 = 0;\n  let sum2 = 0;\n  let x = 0;\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean;\n      sum1 += x;\n      sum2 += x * x;\n    }\n  }\n  if (unbiased) {\n    return (sum2 - (sum1 * sum1) / size) / (size - 1);\n  } else {\n    return (sum2 - (sum1 * sum1) / size) / size;\n  }\n}\n\nfunction centerByRow(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[i]);\n    }\n  }\n}\n\nfunction centerByColumn(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[j]);\n    }\n  }\n}\n\nfunction centerAll(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean);\n    }\n  }\n}\n\nfunction getScaleByRow(matrix) {\n  const scale = [];\n  for (let i = 0; i < matrix.rows; i++) {\n    let sum = 0;\n    for (let j = 0; j < matrix.columns; j++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nfunction scaleByRow(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[i]);\n    }\n  }\n}\n\nfunction getScaleByColumn(matrix) {\n  const scale = [];\n  for (let j = 0; j < matrix.columns; j++) {\n    let sum = 0;\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nfunction scaleByColumn(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[j]);\n    }\n  }\n}\n\nfunction getScaleAll(matrix) {\n  const divider = matrix.size - 1;\n  let sum = 0;\n  for (let j = 0; j < matrix.columns; j++) {\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / divider;\n    }\n  }\n  return Math.sqrt(sum);\n}\n\nfunction scaleAll(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale);\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/stat.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/util.js":
/*!********************************************!*\
  !*** ./node_modules/ml-matrix/src/util.js ***!
  \********************************************/
/*! exports provided: checkRowIndex, checkColumnIndex, checkRowVector, checkColumnVector, checkIndices, checkRowIndices, checkColumnIndices, checkRange, newArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkRowIndex\", function() { return checkRowIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkColumnIndex\", function() { return checkColumnIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkRowVector\", function() { return checkRowVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkColumnVector\", function() { return checkColumnVector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkIndices\", function() { return checkIndices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkRowIndices\", function() { return checkRowIndices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkColumnIndices\", function() { return checkColumnIndices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkRange\", function() { return checkRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"newArray\", function() { return newArray; });\n/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nfunction checkRowIndex(matrix, index, outer) {\n  let max = outer ? matrix.rows : matrix.rows - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Row index out of range');\n  }\n}\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nfunction checkColumnIndex(matrix, index, outer) {\n  let max = outer ? matrix.columns : matrix.columns - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Column index out of range');\n  }\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nfunction checkRowVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.columns) {\n    throw new RangeError(\n      'vector size must be the same as the number of columns',\n    );\n  }\n  return vector;\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nfunction checkColumnVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.rows) {\n    throw new RangeError('vector size must be the same as the number of rows');\n  }\n  return vector;\n}\n\nfunction checkIndices(matrix, rowIndices, columnIndices) {\n  return {\n    row: checkRowIndices(matrix, rowIndices),\n    column: checkColumnIndices(matrix, columnIndices),\n  };\n}\n\nfunction checkRowIndices(matrix, rowIndices) {\n  if (typeof rowIndices !== 'object') {\n    throw new TypeError('unexpected type for row indices');\n  }\n\n  let rowOut = rowIndices.some((r) => {\n    return r < 0 || r >= matrix.rows;\n  });\n\n  if (rowOut) {\n    throw new RangeError('row indices are out of range');\n  }\n\n  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n\n  return rowIndices;\n}\n\nfunction checkColumnIndices(matrix, columnIndices) {\n  if (typeof columnIndices !== 'object') {\n    throw new TypeError('unexpected type for column indices');\n  }\n\n  let columnOut = columnIndices.some((c) => {\n    return c < 0 || c >= matrix.columns;\n  });\n\n  if (columnOut) {\n    throw new RangeError('column indices are out of range');\n  }\n  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);\n\n  return columnIndices;\n}\n\nfunction checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n  if (arguments.length !== 5) {\n    throw new RangeError('expected 4 arguments');\n  }\n  checkNumber('startRow', startRow);\n  checkNumber('endRow', endRow);\n  checkNumber('startColumn', startColumn);\n  checkNumber('endColumn', endColumn);\n  if (\n    startRow > endRow ||\n    startColumn > endColumn ||\n    startRow < 0 ||\n    startRow >= matrix.rows ||\n    endRow < 0 ||\n    endRow >= matrix.rows ||\n    startColumn < 0 ||\n    startColumn >= matrix.columns ||\n    endColumn < 0 ||\n    endColumn >= matrix.columns\n  ) {\n    throw new RangeError('Submatrix indices are out of range');\n  }\n}\n\nfunction newArray(length, value = 0) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array.push(value);\n  }\n  return array;\n}\n\nfunction checkNumber(name, value) {\n  if (typeof value !== 'number') {\n    throw new TypeError(`${name} must be a number`);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/util.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/base.js":
/*!**************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/base.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BaseView; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n\n\nclass BaseView extends _matrix__WEBPACK_IMPORTED_MODULE_0__[\"AbstractMatrix\"] {\n  constructor(matrix, rows, columns) {\n    super();\n    this.matrix = matrix;\n    this.rows = rows;\n    this.columns = columns;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/base.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/column.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/column.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MatrixColumnView; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/ml-matrix/src/util.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./node_modules/ml-matrix/src/views/base.js\");\n\n\n\n\nclass MatrixColumnView extends _base__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(matrix, column) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"checkColumnIndex\"])(matrix, column);\n    super(matrix, matrix.rows, 1);\n    this.column = column;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(rowIndex, this.column, value);\n    return this;\n  }\n\n  get(rowIndex) {\n    return this.matrix.get(rowIndex, this.column);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/column.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/columnSelection.js":
/*!*************************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/columnSelection.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MatrixColumnSelectionView; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/ml-matrix/src/util.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./node_modules/ml-matrix/src/views/base.js\");\n\n\n\n\nclass MatrixColumnSelectionView extends _base__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(matrix, columnIndices) {\n    columnIndices = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"checkColumnIndices\"])(matrix, columnIndices);\n    super(matrix, matrix.rows, columnIndices.length);\n    this.columnIndices = columnIndices;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/columnSelection.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/flipColumn.js":
/*!********************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/flipColumn.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MatrixFlipColumnView; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./node_modules/ml-matrix/src/views/base.js\");\n\n\nclass MatrixFlipColumnView extends _base__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(matrix) {\n    super(matrix, matrix.rows, matrix.columns);\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/flipColumn.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/flipRow.js":
/*!*****************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/flipRow.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MatrixFlipRowView; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./node_modules/ml-matrix/src/views/base.js\");\n\n\nclass MatrixFlipRowView extends _base__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(matrix) {\n    super(matrix, matrix.rows, matrix.columns);\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/flipRow.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/index.js ***!
  \***************************************************/
/*! exports provided: MatrixColumnView, MatrixColumnSelectionView, MatrixFlipColumnView, MatrixFlipRowView, MatrixRowView, MatrixRowSelectionView, MatrixSelectionView, MatrixSubView, MatrixTransposeView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _column__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./column */ \"./node_modules/ml-matrix/src/views/column.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixColumnView\", function() { return _column__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _columnSelection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./columnSelection */ \"./node_modules/ml-matrix/src/views/columnSelection.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixColumnSelectionView\", function() { return _columnSelection__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _flipColumn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./flipColumn */ \"./node_modules/ml-matrix/src/views/flipColumn.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixFlipColumnView\", function() { return _flipColumn__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _flipRow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./flipRow */ \"./node_modules/ml-matrix/src/views/flipRow.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixFlipRowView\", function() { return _flipRow__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _row__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./row */ \"./node_modules/ml-matrix/src/views/row.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixRowView\", function() { return _row__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _rowSelection__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rowSelection */ \"./node_modules/ml-matrix/src/views/rowSelection.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixRowSelectionView\", function() { return _rowSelection__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var _selection__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./selection */ \"./node_modules/ml-matrix/src/views/selection.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixSelectionView\", function() { return _selection__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n/* harmony import */ var _sub__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sub */ \"./node_modules/ml-matrix/src/views/sub.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixSubView\", function() { return _sub__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; });\n\n/* harmony import */ var _transpose__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transpose */ \"./node_modules/ml-matrix/src/views/transpose.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MatrixTransposeView\", function() { return _transpose__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/index.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/row.js":
/*!*************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/row.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MatrixRowView; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/ml-matrix/src/util.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./node_modules/ml-matrix/src/views/base.js\");\n\n\n\n\nclass MatrixRowView extends _base__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(matrix, row) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"checkRowIndex\"])(matrix, row);\n    super(matrix, 1, matrix.columns);\n    this.row = row;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(this.row, columnIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(this.row, columnIndex);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/row.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/rowSelection.js":
/*!**********************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/rowSelection.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MatrixRowSelectionView; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/ml-matrix/src/util.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./node_modules/ml-matrix/src/views/base.js\");\n\n\n\n\nclass MatrixRowSelectionView extends _base__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(matrix, rowIndices) {\n    rowIndices = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"checkRowIndices\"])(matrix, rowIndices);\n    super(matrix, rowIndices.length, matrix.columns);\n    this.rowIndices = rowIndices;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/rowSelection.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/selection.js":
/*!*******************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/selection.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MatrixSelectionView; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/ml-matrix/src/util.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./node_modules/ml-matrix/src/views/base.js\");\n\n\n\n\nclass MatrixSelectionView extends _base__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(matrix, rowIndices, columnIndices) {\n    let indices = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"checkIndices\"])(matrix, rowIndices, columnIndices);\n    super(matrix, indices.row.length, indices.column.length);\n    this.rowIndices = indices.row;\n    this.columnIndices = indices.column;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(\n      this.rowIndices[rowIndex],\n      this.columnIndices[columnIndex],\n      value,\n    );\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(\n      this.rowIndices[rowIndex],\n      this.columnIndices[columnIndex],\n    );\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/selection.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/sub.js":
/*!*************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/sub.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MatrixSubView; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./node_modules/ml-matrix/src/util.js\");\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ \"./node_modules/ml-matrix/src/views/base.js\");\n\n\n\n\nclass MatrixSubView extends _base__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(matrix, startRow, endRow, startColumn, endColumn) {\n    Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"checkRange\"])(matrix, startRow, endRow, startColumn, endColumn);\n    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);\n    this.startRow = startRow;\n    this.startColumn = startColumn;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(\n      this.startRow + rowIndex,\n      this.startColumn + columnIndex,\n      value,\n    );\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(\n      this.startRow + rowIndex,\n      this.startColumn + columnIndex,\n    );\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/sub.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/views/transpose.js":
/*!*******************************************************!*\
  !*** ./node_modules/ml-matrix/src/views/transpose.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MatrixTransposeView; });\n/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ \"./node_modules/ml-matrix/src/views/base.js\");\n\n\nclass MatrixTransposeView extends _base__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(matrix) {\n    super(matrix, matrix.columns, matrix.rows);\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.matrix.set(columnIndex, rowIndex, value);\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.matrix.get(columnIndex, rowIndex);\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/views/transpose.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js":
/*!************************************************************!*\
  !*** ./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WrapperMatrix1D; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n\n\nclass WrapperMatrix1D extends _matrix__WEBPACK_IMPORTED_MODULE_0__[\"AbstractMatrix\"] {\n  constructor(data, options = {}) {\n    const { rows = 1 } = options;\n\n    if (data.length % rows !== 0) {\n      throw new Error('the data length is not divisible by the number of rows');\n    }\n    super();\n    this.rows = rows;\n    this.columns = data.length / rows;\n    this.data = data;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    let index = this._calculateIndex(rowIndex, columnIndex);\n    this.data[index] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    let index = this._calculateIndex(rowIndex, columnIndex);\n    return this.data[index];\n  }\n\n  _calculateIndex(row, column) {\n    return row * this.columns + column;\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js":
/*!************************************************************!*\
  !*** ./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WrapperMatrix2D; });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n\n\nclass WrapperMatrix2D extends _matrix__WEBPACK_IMPORTED_MODULE_0__[\"AbstractMatrix\"] {\n  constructor(data) {\n    super();\n    this.data = data;\n    this.rows = data.length;\n    this.columns = data[0].length;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/wrap/wrap.js":
/*!*************************************************!*\
  !*** ./node_modules/ml-matrix/src/wrap/wrap.js ***!
  \*************************************************/
/*! exports provided: wrap */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wrap\", function() { return wrap; });\n/* harmony import */ var _WrapperMatrix1D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WrapperMatrix1D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js\");\n/* harmony import */ var _WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n\n\n\nfunction wrap(array, options) {\n  if (Array.isArray(array)) {\n    if (array[0] && Array.isArray(array[0])) {\n      return new _WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_1__[\"default\"](array);\n    } else {\n      return new _WrapperMatrix1D__WEBPACK_IMPORTED_MODULE_0__[\"default\"](array, options);\n    }\n  } else {\n    throw new Error('the argument is not an array');\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/ml-matrix/src/wrap/wrap.js?");

/***/ }),

/***/ "./node_modules/tinyqueue/index.js":
/*!*****************************************!*\
  !*** ./node_modules/tinyqueue/index.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TinyQueue; });\n\nclass TinyQueue {\n    constructor(data = [], compare = defaultCompare) {\n        this.data = data;\n        this.length = this.data.length;\n        this.compare = compare;\n\n        if (this.length > 0) {\n            for (let i = (this.length >> 1) - 1; i >= 0; i--) this._down(i);\n        }\n    }\n\n    push(item) {\n        this.data.push(item);\n        this.length++;\n        this._up(this.length - 1);\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.data[0];\n        const bottom = this.data.pop();\n        this.length--;\n\n        if (this.length > 0) {\n            this.data[0] = bottom;\n            this._down(0);\n        }\n\n        return top;\n    }\n\n    peek() {\n        return this.data[0];\n    }\n\n    _up(pos) {\n        const {data, compare} = this;\n        const item = data[pos];\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const current = data[parent];\n            if (compare(item, current) >= 0) break;\n            data[pos] = current;\n            pos = parent;\n        }\n\n        data[pos] = item;\n    }\n\n    _down(pos) {\n        const {data, compare} = this;\n        const halfLength = this.length >> 1;\n        const item = data[pos];\n\n        while (pos < halfLength) {\n            let left = (pos << 1) + 1;\n            let best = data[left];\n            const right = left + 1;\n\n            if (right < this.length && compare(data[right], best) < 0) {\n                left = right;\n                best = data[right];\n            }\n            if (compare(best, item) >= 0) break;\n\n            data[pos] = best;\n            pos = left;\n        }\n\n        data[pos] = item;\n    }\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\n\n//# sourceURL=webpack:///./node_modules/tinyqueue/index.js?");

/***/ }),

/***/ "./src/controller.worker.js":
/*!**********************************!*\
  !*** ./src/controller.worker.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Matcher} = __webpack_require__(/*! ./image-target/matching/matcher.js */ \"./src/image-target/matching/matcher.js\");\nconst {refineHomography} = __webpack_require__(/*! ./image-target/icp/refine_homography.js */ \"./src/image-target/icp/refine_homography.js\");\nconst {estimateHomography} = __webpack_require__(/*! ./image-target/icp/estimate_homography.js */ \"./src/image-target/icp/estimate_homography.js\");\n\nconst AR2_TRACKING_THRESH = 5.0; // default\n\n\nlet projectionTransform = null;\nlet matchingDataList = null;\nlet matcher = null;\n\nonmessage = (msg) => {\n  const {data} = msg;\n\n  if (data.type === 'setup') {\n    projectionTransform = data.projectionTransform;\n    matchingDataList = data.matchingDataList;\n    matcher = new Matcher(data.inputWidth, data.inputHeight);\n  }\n\n  else if (data.type === 'match') {\n    const skipTargetIndexes = data.skipTargetIndexes;\n\n    let matchedTargetIndex = -1;\n    let matchedModelViewTransform = null;\n\n    for (let i = 0; i < matchingDataList.length; i++) {\n      if (skipTargetIndexes.includes(i)) continue;\n\n      const matchResult = matcher.matchDetection(matchingDataList[i], data.featurePoints);\n      if (matchResult === null) continue;\n\n      const {screenCoords, worldCoords} = matchResult;\n      const modelViewTransform = estimateHomography({screenCoords, worldCoords, projectionTransform});\n      if (modelViewTransform === null) continue;\n\n      matchedTargetIndex = i;\n      matchedModelViewTransform = modelViewTransform;\n      break;\n    }\n\n    postMessage({\n      type: 'matchDone',\n      targetIndex: matchedTargetIndex,\n      modelViewTransform: matchedModelViewTransform,\n    });\n  }\n  else if (data.type === 'track') {\n    const {modelViewTransform, selectedFeatures} = data;\n\n    const inlierProbs = [1.0, 0.8, 0.6, 0.4, 0.0];\n    let err = null;\n    let newModelViewTransform = modelViewTransform;\n    let finalModelViewTransform = null;\n    for (let i = 0; i < inlierProbs.length; i++) {\n      let ret = _computeUpdatedTran({modelViewTransform: newModelViewTransform, selectedFeatures, projectionTransform, inlierProb: inlierProbs[i]});\n      err = ret.err;\n      newModelViewTransform = ret.newModelViewTransform;\n      //console.log(\"_computeUpdatedTran\", err)\n\n      if (err < AR2_TRACKING_THRESH) {\n        finalModelViewTransform = newModelViewTransform;\n        break;\n      }\n    }\n\n    postMessage({\n      type: 'trackDone',\n      modelViewTransform: finalModelViewTransform,\n    });\n  }\n};\n\nconst _computeUpdatedTran = ({modelViewTransform, projectionTransform, selectedFeatures, inlierProb}) => {\n  let dx = 0;\n  let dy = 0;\n  let dz = 0;\n  for (let i = 0; i < selectedFeatures.length; i++) {\n    dx += selectedFeatures[i].pos3D.x;\n    dy += selectedFeatures[i].pos3D.y;\n    dz += selectedFeatures[i].pos3D.z;\n  }\n  dx /= selectedFeatures.length;\n  dy /= selectedFeatures.length;\n  dz /= selectedFeatures.length;\n\n  const worldCoords = [];\n  const screenCoords = [];\n  for (let i = 0; i < selectedFeatures.length; i++) {\n    screenCoords.push({x: selectedFeatures[i].pos2D.x, y: selectedFeatures[i].pos2D.y});\n    worldCoords.push({x: selectedFeatures[i].pos3D.x - dx, y: selectedFeatures[i].pos3D.y - dy, z: selectedFeatures[i].pos3D.z - dz});\n  }\n\n  const diffModelViewTransform = [[],[],[]];\n  for (let j = 0; j < 3; j++) {\n    for (let i = 0; i < 3; i++) {\n      diffModelViewTransform[j][i] = modelViewTransform[j][i];\n    }\n  }\n  diffModelViewTransform[0][3] = modelViewTransform[0][0] * dx + modelViewTransform[0][1] * dy + modelViewTransform[0][2] * dz + modelViewTransform[0][3];\n  diffModelViewTransform[1][3] = modelViewTransform[1][0] * dx + modelViewTransform[1][1] * dy + modelViewTransform[1][2] * dz + modelViewTransform[1][3];\n  diffModelViewTransform[2][3] = modelViewTransform[2][0] * dx + modelViewTransform[2][1] * dy + modelViewTransform[2][2] * dz + modelViewTransform[2][3];\n\n  let ret;\n  if (inlierProb < 1) {\n     ret = refineHomography({initialModelViewTransform: diffModelViewTransform, projectionTransform, worldCoords, screenCoords, isRobustMode: true, inlierProb});\n  } else {\n     ret = refineHomography({initialModelViewTransform: diffModelViewTransform, projectionTransform, worldCoords, screenCoords, isRobustMode: false});\n  }\n\n  const newModelViewTransform = [[],[],[]];\n  for (let j = 0; j < 3; j++) {\n    for (let i = 0; i < 3; i++) {\n      newModelViewTransform[j][i] = ret.modelViewTransform[j][i];\n    }\n  }\n  newModelViewTransform[0][3] = ret.modelViewTransform[0][3] - ret.modelViewTransform[0][0] * dx - ret.modelViewTransform[0][1] * dy - ret.modelViewTransform[0][2] * dz;\n  newModelViewTransform[1][3] = ret.modelViewTransform[1][3] - ret.modelViewTransform[1][0] * dx - ret.modelViewTransform[1][1] * dy - ret.modelViewTransform[1][2] * dz;\n  newModelViewTransform[2][3] = ret.modelViewTransform[2][3] - ret.modelViewTransform[2][0] * dx - ret.modelViewTransform[2][1] * dy - ret.modelViewTransform[2][2] * dz;\n\n\n  return {err: ret.err, newModelViewTransform};\n};\n\n\n//# sourceURL=webpack:///./src/controller.worker.js?");

/***/ }),

/***/ "./src/image-target/icp/estimate_homography.js":
/*!*****************************************************!*\
  !*** ./src/image-target/icp/estimate_homography.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Matrix, inverse} = __webpack_require__(/*! ml-matrix */ \"./node_modules/ml-matrix/src/index.js\");\n\n// build world matrix with list of matching worldCoords|screenCoords\n//\n// Step 1. estimate homography with list of pairs\n// Ref: https://www.uio.no/studier/emner/matnat/its/TEK5030/v19/lect/lecture_4_3-estimating-homographies-from-feature-correspondences.pdf  (Basic homography estimation from points)\n//\n// Step 2. decompose homography into rotation and translation matrixes (i.e. world matrix)\n// Ref: can anyone provide reference?\nconst estimateHomography = ({screenCoords, worldCoords, projectionTransform}) => {\n  const num = screenCoords.length;\n  const AData = [];\n  const BData = [];\n  for (let j = 0; j < num; j++) {\n    const row1 = [\n      worldCoords[j].x,\n      worldCoords[j].y,\n      1,\n      0,\n      0,\n      0,\n      -(worldCoords[j].x * screenCoords[j].x),\n      -(worldCoords[j].y * screenCoords[j].x),\n    ];\n    const row2 = [\n      0,\n      0,\n      0,\n      worldCoords[j].x,\n      worldCoords[j].y,\n      1,\n      -(worldCoords[j].x * screenCoords[j].y),\n      -(worldCoords[j].y * screenCoords[j].y),\n    ];\n    AData.push(row1);\n    AData.push(row2);\n\n    BData.push([screenCoords[j].x]);\n    BData.push([screenCoords[j].y]);\n  }\n\n  const A = new Matrix(AData);\n  const B = new Matrix(BData);\n  const AT = A.transpose();\n  const ATA = AT.mmul(A);\n  const ATB = AT.mmul(B);\n  const ATAInv = inverse(ATA);\n  const C = ATAInv.mmul(ATB).to1DArray();\n\n  const H = new Matrix([\n    [C[0], C[1], C[2]],\n    [C[3], C[4], C[5]],\n    [C[6], C[7], 1]\n  ]);\n\n  const K = new Matrix(projectionTransform);\n  const KInv = inverse(K);\n\n  const _KInvH = KInv.mmul(H);\n  const KInvH = _KInvH.to1DArray();\n\n  const norm1 = Math.sqrt( KInvH[0] * KInvH[0] + KInvH[3] * KInvH[3] + KInvH[6] * KInvH[6]);\n  const norm2 = Math.sqrt( KInvH[1] * KInvH[1] + KInvH[4] * KInvH[4] + KInvH[7] * KInvH[7]);\n  const tnorm = (norm1 + norm2) / 2;\n\n  const rotate = [];\n  rotate[0] = KInvH[0] / norm1;\n  rotate[3] = KInvH[3] / norm1;\n  rotate[6] = KInvH[6] / norm1;\n\n  rotate[1] = KInvH[1] / norm2;\n  rotate[4] = KInvH[4] / norm2;\n  rotate[7] = KInvH[7] / norm2;\n\n  rotate[2] = rotate[3] * rotate[7] - rotate[6] * rotate[4];\n  rotate[5] = rotate[6] * rotate[1] - rotate[0] * rotate[7];\n  rotate[8] = rotate[0] * rotate[4] - rotate[1] * rotate[3];\n\n  const norm3 = Math.sqrt(rotate[2] * rotate[2] + rotate[5] * rotate[5] + rotate[8] * rotate[8]);\n  rotate[2] /= norm3;\n  rotate[5] /= norm3;\n  rotate[8] /= norm3;\n\n  // TODO: artoolkit has check_rotation() that somehow switch the rotate vector. not sure what that does. Can anyone advice?\n  // https://github.com/artoolkitx/artoolkit5/blob/5bf0b671ff16ead527b9b892e6aeb1a2771f97be/lib/SRC/ARICP/icpUtil.c#L215\n\n  const tran = []\n  tran[0] = KInvH[2] / tnorm;\n  tran[1] = KInvH[5] / tnorm;\n  tran[2] = KInvH[8] / tnorm;\n\n  let initialModelViewTransform = [\n    [rotate[0], rotate[1], rotate[2], tran[0]],\n    [rotate[3], rotate[4], rotate[5], tran[1]],\n    [rotate[6], rotate[7], rotate[8], tran[2]]\n  ];\n\n  return initialModelViewTransform;\n};\n\nmodule.exports = {\n  estimateHomography\n}\n\n\n//# sourceURL=webpack:///./src/image-target/icp/estimate_homography.js?");

/***/ }),

/***/ "./src/image-target/icp/refine_homography.js":
/*!***************************************************!*\
  !*** ./src/image-target/icp/refine_homography.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {Matrix, inverse} = __webpack_require__(/*! ml-matrix */ \"./node_modules/ml-matrix/src/index.js\");\nconst {applyModelViewProjectionTransform, buildModelViewProjectionTransform, computeScreenCoordiate} = __webpack_require__(/*! ./utils.js */ \"./src/image-target/icp/utils.js\");\n\n// TODO: the error computation seems problematic. should it be relative to the size of detection?\n//       now the values are hardcoded, e.g. K2_Factor = 4\nconst K2_FACTOR = 4.0;\nconst ICP_MAX_LOOP = 10;\nconst ICP_BREAK_LOOP_ERROR_THRESH = 0.1;\nconst ICP_BREAK_LOOP_ERROR_RATIO_THRESH = 0.99;\nconst ICP_BREAK_LOOP_ERROR_THRESH2 = 4.0;\n\n// ICP iteration with points\n// Can someone provide theoretical reference?\nconst refineHomography = ({initialModelViewTransform, projectionTransform, worldCoords, screenCoords, isRobustMode, inlierProb}) => {\n  let modelViewTransform = initialModelViewTransform;\n\n  let err0 = 0.0;\n  let err1 = 0.0;\n  for (let l = 0; l <= ICP_MAX_LOOP; l++) {\n\n    const modelViewProjectionTransform = buildModelViewProjectionTransform(projectionTransform, modelViewTransform);\n\n    const E = [];\n    const dxs = [];\n    const dys = [];\n    for (let n = 0; n < worldCoords.length; n++) {\n      const u = computeScreenCoordiate(modelViewProjectionTransform, worldCoords[n].x, worldCoords[n].y, worldCoords[n].z);\n      const dx = screenCoords[n].x - u.x;\n      const dy = screenCoords[n].y - u.y;\n      dxs.push(dx);\n      dys.push(dy);\n      E.push(dx * dx + dy * dy);\n    }\n\n    let K2; // robust mode only\n    err1 = 0.0;\n    if (isRobustMode) {\n      const inlierNum = Math.max(3, Math.floor(worldCoords.length * inlierProb) - 1);\n      const E2 = []; // for robust mode only\n      for (let n = 0; n < worldCoords.length; n++) {\n        E2.push(E[n]);\n      }\n      E2.sort((a, b) => {return a-b;});\n\n\n      K2 = Math.max(E2[inlierNum] * K2_FACTOR, 16.0);\n      for (let n = 0; n < worldCoords.length; n++) {\n        if (E2[n] > K2) err1 += K2/ 6;\n        else err1 +=  K2/6.0 * (1.0 - (1.0-E2[n]/K2)*(1.0-E2[n]/K2)*(1.0-E2[n]/K2));\n      }\n    } else {\n      for (let n = 0; n < worldCoords.length; n++) {\n        err1 += E[n];\n      }\n    }\n    err1 /= worldCoords.length;\n\n    if (err1 < ICP_BREAK_LOOP_ERROR_THRESH) break;\n    if (l > 0 && err1 < ICP_BREAK_LOOP_ERROR_THRESH2 && err1/err0 > ICP_BREAK_LOOP_ERROR_RATIO_THRESH) break;\n    if (l === ICP_MAX_LOOP) break;\n\n    err0 = err1;\n\n    const dU = [];\n    const allJ_U_S = [];\n    for (let n = 0; n < worldCoords.length; n++) {\n      if (isRobustMode && E[n] > K2) {\n        continue;\n      }\n\n      const J_U_S = _getJ_U_S({modelViewProjectionTransform, modelViewTransform, projectionTransform, worldCoord: worldCoords[n]});\n\n      if (isRobustMode) {\n        const W = (1.0 - E[n]/K2)*(1.0 - E[n]/K2);\n\n        for (let j = 0; j < 2; j++) {\n          for (let i = 0; i < 6; i++) {\n            J_U_S[j][i] *= W;\n          }\n        }\n        dU.push([dxs[n] * W]);\n        dU.push([dys[n] * W]);\n      } else {\n        dU.push([dxs[n]]);\n        dU.push([dys[n]]);\n      }\n\n      for (let i = 0; i < J_U_S.length; i++) {\n        allJ_U_S.push(J_U_S[i]);\n      }\n    }\n\n    const dS = _getDeltaS({dU, J_U_S: allJ_U_S});\n    if (dS === null) break;\n\n    modelViewTransform = _updateModelViewTransform({modelViewTransform, dS});\n  }\n  return {modelViewTransform, err: err1};\n}\n\n_updateModelViewTransform = ({modelViewTransform, dS}) => {\n  const q = [];\n  let ra = dS[0] * dS[0] + dS[1] * dS[1] + dS[2] * dS[2];\n  if( ra < 0.000001 ) {\n    q[0] = 1.0;\n    q[1] = 0.0;\n    q[2] = 0.0;\n    q[3] = 0.0;\n  } else {\n    ra = Math.sqrt(ra);\n    q[0] = dS[0] / ra;\n    q[1] = dS[1] / ra;\n    q[2] = dS[2] / ra;\n    q[3] = ra;\n  }\n  q[4] = dS[3];\n  q[5] = dS[4];\n  q[6] = dS[5];\n\n  const cra = Math.cos(q[3]);\n  const one_cra = 1.0 - cra;\n  const sra = Math.sin(q[3]);\n  const mat = [[],[],[]];\n\n  mat[0][0] = q[0]*q[0]*one_cra + cra;\n  mat[0][1] = q[0]*q[1]*one_cra - q[2]*sra;\n  mat[0][2] = q[0]*q[2]*one_cra + q[1]*sra;\n  mat[0][3] = q[4];\n  mat[1][0] = q[1]*q[0]*one_cra + q[2]*sra;\n  mat[1][1] = q[1]*q[1]*one_cra + cra;\n  mat[1][2] = q[1]*q[2]*one_cra - q[0]*sra;\n  mat[1][3] = q[5];\n  mat[2][0] = q[2]*q[0]*one_cra - q[1]*sra;\n  mat[2][1] = q[2]*q[1]*one_cra + q[0]*sra;\n  mat[2][2] = q[2]*q[2]*one_cra + cra;\n  mat[2][3] = q[6];\n\n  const mat2 = [[],[],[]];\n  for (let j = 0; j < 3; j++ ) {\n    for (let i = 0; i < 4; i++ ) {\n      mat2[j][i] = modelViewTransform[j][0] * mat[0][i]\n                   + modelViewTransform[j][1] * mat[1][i]\n                   + modelViewTransform[j][2] * mat[2][i];\n    }\n    mat2[j][3] += modelViewTransform[j][3];\n  }\n  return mat2;\n}\n\n_getDeltaS = ({dU, J_U_S}) => {\n  const J = new Matrix(J_U_S);\n  const U = new Matrix(dU);\n\n  const JT = J.transpose();\n  const JTJ = JT.mmul(J);\n  const JTU = JT.mmul(U);\n\n  let JTJInv;\n  try {\n    JTJInv = inverse(JTJ);\n  } catch (e) {\n    return null;\n  }\n\n  const S = JTJInv.mmul(JTU);\n  return S.to1DArray();\n}\n\n_getJ_U_S = ({modelViewProjectionTransform, modelViewTransform, projectionTransform, worldCoord}) => {\n  const T = modelViewTransform;\n  const {x, y, z} = worldCoord;\n\n  const u = applyModelViewProjectionTransform(modelViewProjectionTransform, x, y, z);\n\n  const z2 = u.z * u.z;\n  const J_U_Xc = [[],[]];\n  J_U_Xc[0][0] = (projectionTransform[0][0] * u.z - projectionTransform[2][0] * u.x) / z2;\n  J_U_Xc[0][1] = (projectionTransform[0][1] * u.z - projectionTransform[2][1] * u.x) / z2;\n  J_U_Xc[0][2] = (projectionTransform[0][2] * u.z - projectionTransform[2][2] * u.x) / z2;\n  J_U_Xc[1][0] = (projectionTransform[1][0] * u.z - projectionTransform[2][0] * u.y) / z2;\n  J_U_Xc[1][1] = (projectionTransform[1][1] * u.z - projectionTransform[2][1] * u.y) / z2;\n  J_U_Xc[1][2] = (projectionTransform[1][2] * u.z - projectionTransform[2][2] * u.y) / z2;\n\n  const J_Xc_S = [\n    [T[0][2] * y - T[0][1] * z, T[0][0] * z - T[0][2] * x, T[0][1] * x - T[0][0] * y, T[0][0], T[0][1], T[0][2]],\n    [T[1][2] * y - T[1][1] * z, T[1][0] * z - T[1][2] * x, T[1][1] * x - T[1][0] * y, T[1][0], T[1][1], T[1][2]],\n    [T[2][2] * y - T[2][1] * z, T[2][0] * z - T[2][2] * x, T[2][1] * x - T[2][0] * y, T[2][0], T[2][1], T[2][2]],\n  ];\n\n  const J_U_S = [[], []];\n  for (let j = 0; j < 2; j++) {\n    for (let i = 0; i < 6; i++) {\n      J_U_S[j][i] = 0.0;\n      for (let k = 0; k < 3; k++ ) {\n        J_U_S[j][i] += J_U_Xc[j][k] * J_Xc_S[k][i];\n      }\n    }\n  }\n  return J_U_S;\n}\n\nmodule.exports = {\n  refineHomography\n}\n\n\n//# sourceURL=webpack:///./src/image-target/icp/refine_homography.js?");

/***/ }),

/***/ "./src/image-target/icp/utils.js":
/*!***************************************!*\
  !*** ./src/image-target/icp/utils.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const buildModelViewProjectionTransform = (projectionTransform, modelViewTransform) => {\n  const modelViewProjectionTransform = [[],[],[]];\n  for (let j = 0; j < 3; j++ ) {\n    for (let i = 0; i < 4; i++) {\n      modelViewProjectionTransform[j][i] = projectionTransform[j][0] * modelViewTransform[0][i]\n                                         + projectionTransform[j][1] * modelViewTransform[1][i]\n                                         + projectionTransform[j][2] * modelViewTransform[2][i];\n    }\n  }\n  return modelViewProjectionTransform;\n}\n\nconst applyModelViewProjectionTransform = (modelViewProjectionTransform, x, y, z) => {\n  const ux = modelViewProjectionTransform[0][0] * x + modelViewProjectionTransform[0][1] * y\n     + modelViewProjectionTransform[0][2] * z + modelViewProjectionTransform[0][3];\n  const uy = modelViewProjectionTransform[1][0] * x + modelViewProjectionTransform[1][1] * y\n     + modelViewProjectionTransform[1][2] * z + modelViewProjectionTransform[1][3];\n  const uz  = modelViewProjectionTransform[2][0] * x + modelViewProjectionTransform[2][1] * y\n     + modelViewProjectionTransform[2][2] * z + modelViewProjectionTransform[2][3];\n  return {x: ux, y: uy, z: uz};\n}\n\nconst computeScreenCoordiate = (modelViewProjectionTransform, x, y, z) => {\n  const {x: ux, y: uy, z: uz} = applyModelViewProjectionTransform(modelViewProjectionTransform, x, y, z);\n  if( Math.abs(uz) < 0.000001 ) return null;\n  return {x: ux/uz, y: uy/uz};\n}\n\nconst screenToMarkerCoordinate = (modelViewProjectionTransform, sx, sy) => {\n  const c11 = modelViewProjectionTransform[2][0] * sx - modelViewProjectionTransform[0][0];\n  const c12 = modelViewProjectionTransform[2][1] * sx - modelViewProjectionTransform[0][1];\n  const c21 = modelViewProjectionTransform[2][0] * sy - modelViewProjectionTransform[1][0];\n  const c22 = modelViewProjectionTransform[2][1] * sy - modelViewProjectionTransform[1][1];\n  const b1  = modelViewProjectionTransform[0][3] - modelViewProjectionTransform[2][3] * sx;\n  const b2  = modelViewProjectionTransform[1][3] - modelViewProjectionTransform[2][3] * sy;\n\n  const m = c11 * c22 - c12 * c21;\n  return {\n    x: (c22 * b1 - c12 * b2) / m,\n    y: (c11 * b2 - c21 * b1) / m\n  }\n}\n\nmodule.exports = {\n  screenToMarkerCoordinate,\n  buildModelViewProjectionTransform,\n  applyModelViewProjectionTransform,\n  computeScreenCoordiate\n}\n\n\n//# sourceURL=webpack:///./src/image-target/icp/utils.js?");

/***/ }),

/***/ "./src/image-target/matching/hamming-distance.js":
/*!*******************************************************!*\
  !*** ./src/image-target/matching/hamming-distance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Fast computation on number of bit sets\n// Ref: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\nconst compute = (options) => {\n  const {v1, v2} = options;\n  let d = 0;\n  for (let i = 0; i < v1.length; i++) {\n    let x = (v1[i] ^ v2[i]) >>> 0;\n    d += bitCount(x);\n  }\n  return d;\n}\n\nconst bitCount = (v) => {\n  var c = v - ((v >> 1) & 0x55555555);\n  c = ((c >> 2) & 0x33333333) + (c & 0x33333333);\n  c = ((c >> 4) + c) & 0x0F0F0F0F;\n  c = ((c >> 8) + c) & 0x00FF00FF;\n  c = ((c >> 16) + c) & 0x0000FFFF;\n  return c;\n}\n\nmodule.exports = {\n  compute\n};\n\n\n//# sourceURL=webpack:///./src/image-target/matching/hamming-distance.js?");

/***/ }),

/***/ "./src/image-target/matching/homography.js":
/*!*************************************************!*\
  !*** ./src/image-target/matching/homography.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {createRandomizer} = __webpack_require__(/*! ../utils/randomizer.js */ \"./src/image-target/utils/randomizer.js\");\nconst {quadrilateralConvex, matrixInverse33, smallestTriangleArea, multiplyPointHomographyInhomogenous, checkThreePointsConsistent, checkFourPointsConsistent, determinant} = __webpack_require__(/*! ../utils/geometry.js */ \"./src/image-target/utils/geometry.js\");\n\nconst EPSILON = 0.0000000000001;\nconst SQRT2 = 1.41421356237309504880;\nconst HOMOGRAPHY_DEFAULT_CAUCHY_SCALE = 0.01;\nconst HOMOGRAPHY_DEFAULT_NUM_HYPOTHESES = 1024;\nconst HOMOGRAPHY_DEFAULT_MAX_TRIALS = 1064;\nconst HOMOGRAPHY_DEFAULT_CHUNK_SIZE = 50;\n\n// testPoints is four corners of keyframe\nconst computeHomography = (options) => {\n  const {srcPoints, dstPoints, keyframe} = options;\n\n  const testPoints = [\n    [0, 0],\n    [keyframe.width, 0],\n    [keyframe.width, keyframe.height],\n    [0, keyframe.height]\n  ]\n\n  const sampleSize = 4; // use four points to compute homography\n  if (srcPoints.length < sampleSize) return null;\n\n  const scale = HOMOGRAPHY_DEFAULT_CAUCHY_SCALE;\n  const oneOverScale2 = 1.0 / (scale * scale);\n  const chuckSize = Math.min(HOMOGRAPHY_DEFAULT_CHUNK_SIZE, srcPoints.length);\n\n  const randomizer = createRandomizer();\n\n  const perm = [];\n  for (let i = 0; i < srcPoints.length; i++) {\n    perm[i] = i;\n  }\n\n  randomizer.arrayShuffle({arr: perm, sampleSize: perm.length});\n\n  // build numerous hypotheses by randoming draw four points\n  // TODO: optimize: if number of points is less than certain number, can brute force all combinations\n  let trial = 0;\n  const Hs = [];\n  while (trial < HOMOGRAPHY_DEFAULT_MAX_TRIALS && Hs.length < HOMOGRAPHY_DEFAULT_NUM_HYPOTHESES) {\n\n    randomizer.arrayShuffle({arr: perm, sampleSize: sampleSize});\n\n    trial +=1;\n\n    if (!checkFourPointsConsistent(\n      srcPoints[perm[0]], srcPoints[perm[1]], srcPoints[perm[2]], srcPoints[perm[3]],\n      dstPoints[perm[0]], dstPoints[perm[1]], dstPoints[perm[2]], dstPoints[perm[3]])) {\n      continue;\n    }\n\n    const H = _solveHomographyFourPoints({\n      srcPoints: [srcPoints[perm[0]], srcPoints[perm[1]], srcPoints[perm[2]], srcPoints[perm[3]]],\n      dstPoints: [dstPoints[perm[0]], dstPoints[perm[1]], dstPoints[perm[2]], dstPoints[perm[3]]],\n    });\n\n    if (H === null) continue;\n\n    if(!_checkHomographyPointsGeometricallyConsistent({H, testPoints})) {\n      continue;\n    }\n\n    Hs.push(H);\n  }\n\n  if (Hs.length === 0) return null;\n\n  // pick the best hypothesis\n  const hypotheses = [];\n  for (let i = 0; i < Hs.length; i++) {\n    hypotheses.push({\n      H: Hs[i],\n      cost: 0\n    })\n  }\n\n  let curChuckSize = chuckSize;\n  for (let i = 0; i < srcPoints.length && hypotheses.length > 2; i += curChuckSize) {\n    curChuckSize = Math.min(chuckSize, srcPoints.length - i);\n    let chuckEnd = i + curChuckSize;\n\n    for (let j = 0; j < hypotheses.length; j++) {\n      for (let k = i; k < chuckEnd; k++) {\n        const cost = _cauchyProjectiveReprojectionCost({H: hypotheses[j].H, srcPoint: srcPoints[k], dstPoint: dstPoints[k], oneOverScale2});\n        hypotheses[j].cost += cost;\n      }\n    }\n\n    hypotheses.sort((h1, h2) => {return h1.cost - h2.cost});\n    hypotheses.splice(-Math.floor((hypotheses.length+1)/2)); // keep the best half\n  }\n\n  let bestIndex = 0;\n  for (let i = 1; i < hypotheses.length; i++) {\n    if (hypotheses[i].cost < hypotheses[bestIndex].cost) bestIndex = i;\n  }\n\n  const finalH = _normalizeHomography({inH: hypotheses[bestIndex].H});\n\n  if (!_checkHeuristics({H: finalH, testPoints, keyframe})) return null;\n  return finalH;\n}\n\nconst _checkHeuristics = ({H, testPoints, keyframe}) => {\n  const HInv = matrixInverse33(H, 0.00001);\n  // console.log(\"final H Inv: \", HInv);\n  if (HInv === null) return false;\n\n  const mp = []\n  for (let i = 0; i < testPoints.length; i++) { // 4 test points, corner of keyframe\n    mp.push(multiplyPointHomographyInhomogenous(testPoints[i], HInv));\n  }\n  const smallArea = smallestTriangleArea(mp[0], mp[1], mp[2], mp[3]);\n\n  if (smallArea < keyframe.width * keyframe.height * 0.0001) return false;\n\n  if (!quadrilateralConvex(mp[0], mp[1], mp[2], mp[3])) return false;\n\n  return true;\n}\n\nconst _normalizeHomography = ({inH}) => {\n  const oneOver = 1.0 / inH[8];\n\n  const H = [];\n  for (let i = 0; i < 8; i++) {\n    H[i] = inH[i] * oneOver;\n  }\n  H[8] = 1.0;\n  return H;\n}\n\nconst _cauchyProjectiveReprojectionCost = ({H, srcPoint, dstPoint, oneOverScale2}) => {\n  const x = multiplyPointHomographyInhomogenous(srcPoint, H);\n  const f =[\n    x[0] - dstPoint[0],\n    x[1] - dstPoint[1]\n  ];\n  return Math.log(1 + (f[0]*f[0]+f[1]*f[1]) * oneOverScale2);\n}\n\nconst _checkHomographyPointsGeometricallyConsistent = ({H, testPoints}) => {\n  const mappedPoints = [];\n  for (let i = 0; i < testPoints.length; i++) {\n    mappedPoints[i] = multiplyPointHomographyInhomogenous(testPoints[i], H);\n    //console.log(\"map\", testPoints[i], mappedPoints[i], H);\n  }\n  for (let i = 0; i < testPoints.length; i++) {\n    const i1 = i;\n    const i2 = (i+1) % testPoints.length;\n    const i3 = (i+2) % testPoints.length;\n    if (!checkThreePointsConsistent(\n      testPoints[i1], testPoints[i2], testPoints[i3],\n      mappedPoints[i1], mappedPoints[i2], mappedPoints[i3])) return false;\n  }\n  return true;\n}\n\n// Condition four 2D points such that the mean is zero and the standard deviation is sqrt(2).\nconst _condition4Points2d = ({x1, x2, x3, x4}) => {\n  const mu = [];\n  const d1 = [];\n  const d2 = [];\n  const d3 = [];\n  const d4 = [];\n\n  mu[0] = (x1[0]+x2[0]+x3[0]+x4[0])/4;\n  mu[1] = (x1[1]+x2[1]+x3[1]+x4[1])/4;\n\n  d1[0] = x1[0]-mu[0];\n  d1[1] = x1[1]-mu[1];\n  d2[0] = x2[0]-mu[0];\n  d2[1] = x2[1]-mu[1];\n  d3[0] = x3[0]-mu[0];\n  d3[1] = x3[1]-mu[1];\n  d4[0] = x4[0]-mu[0];\n  d4[1] = x4[1]-mu[1];\n\n  const ds1 = Math.sqrt(d1[0]*d1[0]+d1[1]*d1[1]);\n  const ds2 = Math.sqrt(d2[0]*d2[0]+d2[1]*d2[1]);\n  const ds3 = Math.sqrt(d3[0]*d3[0]+d3[1]*d3[1]);\n  const ds4 = Math.sqrt(d4[0]*d4[0]+d4[1]*d4[1]);\n  const d = (ds1+ds2+ds3+ds4)/4;\n\n  if (d == 0) return null;\n\n  const s = (1.0/d)*SQRT2;\n\n  const xp1 = [];\n  const xp2 = [];\n  const xp3 = [];\n  const xp4 = [];\n\n  xp1[0] = d1[0]*s;\n  xp1[1] = d1[1]*s;\n  xp2[0] = d2[0]*s;\n  xp2[1] = d2[1]*s;\n  xp3[0] = d3[0]*s;\n  xp3[1] = d3[1]*s;\n  xp4[0] = d4[0]*s;\n  xp4[1] = d4[1]*s;\n\n  return {xp1, xp2, xp3, xp4, s, t: mu};\n}\n\nconst _solveHomographyFourPoints = ({srcPoints, dstPoints}) => {\n  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {\n    window.debug.homographyIndex += 1;\n    const dHomography = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex];\n    const {x1, x2, x3, x4, xp1, xp2, xp3, xp4} = dHomography;\n    const l1 = [srcPoints[0],srcPoints[1],srcPoints[2],srcPoints[3],dstPoints[0],dstPoints[1],dstPoints[2],dstPoints[3]];\n    const l2 = [x1, x2, x3, x4, xp1, xp2, xp3, xp4];\n    for (let i = 0; i < l1.length; i++) {\n      if (!window.cmp(l1[i][0], l2[i][0]) || !window.cmp(l1[i][1], l2[i][1])) {\n        console.log('INCORRECT homography points', window.debug.homographyIndex, i, l1[i], l2[i]);\n      }\n    }\n  }\n\n  const res1 = _condition4Points2d({x1: srcPoints[0], x2: srcPoints[1], x3: srcPoints[2], x4: srcPoints[3]});\n\n  if (res1 === null) return null;\n\n  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {\n    const dHomography = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex];\n    const {x1p, x2p, x3p, x4p, t, s} = dHomography;\n    const l1 = [res1.xp1, res1.xp2, res1.xp3, res1.xp4, res1.t];\n    const l2 = [x1p, x2p, x3p, x4p, t];\n    for (let i = 0; i < l1.length; i++) {\n      if (!window.cmp(l1[i][0], l2[i][0]) || !window.cmp(l1[i][1], l2[i][1])) {\n        console.log('INCORRECT homography res1', window.debug.homographyIndex, i, l1[i], l2[i]);\n      }\n    }\n    if (!window.cmp(res1.s, s)) {\n      console.log('INCORRECT homography res1 S', window.debug.homographyIndex, res1.s, s);\n    }\n  }\n\n  const res2 = _condition4Points2d({x1: dstPoints[0], x2: dstPoints[1], x3: dstPoints[2], x4: dstPoints[3]});\n  if (res2 === null) return null;\n\n  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {\n    const dHomography = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex];\n    const {xp1p, xp2p, xp3p, xp4p, tp, sp} = dHomography;\n    const l1 = [res2.xp1, res2.xp2, res2.xp3, res2.xp4, res2.t];\n    const l2 = [xp1p, xp2p, xp3p, xp4p, tp];\n    for (let i = 0; i < l1.length; i++) {\n      if (!window.cmp(l1[i][0], l2[i][0]) || !window.cmp(l1[i][1], l2[i][1])) {\n        console.log('INCORRECT homography res1', window.debug.homographyIndex, i, l1[i], l2[i]);\n      }\n    }\n    if (!window.cmp(res2.s, sp)) {\n      console.log('INCORRECT homography res1 S', window.debug.homographyIndex, i, res2.s, sp);\n    }\n  }\n\n  const Hn = _solveHomography4PointsInhomogenous({\n    x1: res1.xp1, x2: res1.xp2, x3: res1.xp3, x4: res1.xp4,\n    xp1: res2.xp1, xp2: res2.xp2, xp3: res2.xp3, xp4: res2.xp4,\n  });\n\n  if (Hn === null) return null;\n\n  if (Math.abs(determinant(Hn)) < 0.00001) return null;\n\n  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {\n    const dHomography = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex];\n    const dHn = dHomography.Hn;\n    if (!window.cmpArray(Hn, dHn, 0.001)) {\n      console.log(\"INCORRECT Hn\", window.debug.querykeyframeIndex, window.debug.homographyIndex, Hn, dHn);\n    }\n    const dDetH = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].detH;\n    if (!window.cmp(determinant(Hn), dDetH)) {\n      console.log(\"INCORRECT determinant\", determinant(Hn), dDetH);\n    }\n  }\n\n  const H = _denomalizeHomography({H: Hn, s: res1.s, t: res1.t, sp: res2.s, tp: res2.t});\n\n  return H;\n}\n\n// denormalize homography\n// Hp = inv(Tp)*H*T\nconst _denomalizeHomography = ({H, s, t, sp, tp}) => {\n  const a = H[6]*tp[0];\n  const b = H[7]*tp[0];\n  const c = H[0]/sp;\n  const d = H[1]/sp;\n  const apc = a+c;\n  const bpd = b+d;\n\n  const e = H[6]*tp[1];\n  const f = H[7]*tp[1];\n  const g = H[3]/sp;\n  const h = H[4]/sp;\n  const epg = e+g;\n  const fph = f+h;\n\n  const stx = s*t[0];\n  const sty = s*t[1];\n\n  const Hp = [];\n  Hp[0] = s*apc;\n  Hp[1] = s*bpd;\n  Hp[2] = H[8]*tp[0] + H[2]/sp - stx*apc - sty*bpd;\n\n  Hp[3] = s*epg;\n  Hp[4] = s*fph;\n  Hp[5] = H[8]*tp[1] + H[5]/sp - stx*epg - sty*fph;\n\n  Hp[6] = H[6]*s;\n  Hp[7] = H[7]*s;\n  Hp[8] = H[8] - Hp[6]*t[0] - Hp[7]*t[1];\n\n  return Hp;\n};\n\n// can someone verify the implementation of this QR decomposition?\nconst _solveHomography4PointsInhomogenous = ({x1, x2, x3, x4, xp1, xp2, xp3, xp4}) => {\n  const xList = [x1, x2, x3, x4];\n  const xpList = [xp1, xp2, xp3, xp4];\n\n  const A = []; // 8 x 9\n  for (let i = 0; i < 4; i++) {\n    const offset = i * 18;\n    const x = xList[i];\n    const xp = xpList[i];\n    A[offset+0] = -x[0];\n    A[offset+1] = -x[1];\n    A[offset+2] = -1;\n    A[offset+3] = 0;\n    A[offset+4] = 0;\n    A[offset+5] = 0;\n    A[offset+6] = xp[0]*x[0];\n    A[offset+7] = xp[0]*x[1];\n    A[offset+8] = xp[0];\n    A[offset+9] = 0;\n    A[offset+10] = 0;\n    A[offset+11] = 0;\n    A[offset+12] = -x[0];\n    A[offset+13] = -x[1];\n    A[offset+14] = -1;\n    A[offset+15] = xp[1]*x[0];\n    A[offset+16] = xp[1]*x[1];\n    A[offset+17] = xp[1];\n  }\n\n  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {\n    const dA = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].A;\n    if (!window.cmpArray(A, dA)) {\n      console.log(\"INCORRECT A\", window.debug.querykeyframeIndex, window.debug.homographyIndex, A, dA);\n    }\n  }\n\n  const Q = [];\n  for (let i = 0; i < 72; i++) {\n    Q[i] = A[i];\n  }\n\n  // solve x for Ax=0 with QR decomposition with Gram-Schmidt\n  for (let row = 0; row < 8; row++) {\n    if (row > 0) {\n      for (let j = row; j < 8; j++) {\n        // project a vector \"a\" onto a normalized basis vector \"e\".\n        // x = x - dot(a,e)*e\n\n        let d = 0; // dot(a, e);\n        for (let i = 0; i < 9; i++) {\n          d += Q[(row-1) * 9 + i] * A[j * 9 + i];\n        }\n\n        for (let i = 0; i < 9; i++) {\n          Q[j * 9 + i] -= d * Q[ (row-1) * 9 + i];\n        }\n      }\n    }\n\n    let maxValue = -1;\n    let maxRow = -1;\n    const ss = [];\n    for (let j = row; j < 8; j++) {\n      ss[j] = 0;\n      for (let i = 0; i < 9; i++) {\n        ss[j] += (Q[j*9+i] * Q[j*9+i]);\n      }\n      if (ss[j] > maxValue) {\n        maxValue = ss[j];\n        maxRow = j;\n      }\n    }\n    if ( Math.abs(ss[maxRow]) < EPSILON) {\n      return null; // no solution\n    }\n\n    // swap current row with maxindex row\n    if (row !== maxRow) {\n      for (let i = 0; i < 9; i++) {\n        let tmp = A[row * 9 + i];\n        A[row * 9 + i] = A[maxRow * 9 + i];\n        A[maxRow * 9 + i] = tmp;\n\n        let tmp2 = Q[row * 9 + i];\n        Q[row * 9 + i] = Q[maxRow * 9 + i];\n        Q[maxRow * 9 + i] = tmp2;\n      }\n    }\n\n    for (let i = 0; i < 9; i++) {\n      Q[row * 9 + i] = 1.0 * Q[row * 9 + i] / Math.sqrt(ss[maxRow]);\n    }\n  }\n\n  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {\n    const dQ = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].Q8;\n    if (!window.cmpArray(Q, dQ, 0.001)) {\n      console.log(\"INCORRECT Q8\", window.debug.querykeyframeIndex, window.debug.homographyIndex, Q, dQ);\n    }\n  }\n\n  // compute x from Q\n  const w = [];\n  const X = [];\n  for (let row = 0; row < 9; row++) {\n    for (let i = 0; i < 9; i++) {\n      X[row * 9 + i] = (Q[i] * -Q[row]);\n    }\n    X[row * 9 + row] = 1 + X[row * 9 + row];\n\n    for (let j = 1; j < 8; j++) {\n      for(let i = 0; i < 9; i++) {\n        X[row * 9 + i] += (Q[j * 9 + i] * -Q[j * 9 + row]);\n      }\n    }\n\n    let ss = 0;\n    for (let i = 0; i < 9; i++) {\n      ss += (X[row * 9 + i] * X[row * 9 + i]);\n    }\n    if (Math.abs(ss) < EPSILON) {\n      w[row] = 0;\n      continue;\n    }\n\n    w[row] = Math.sqrt(ss);\n    for (let i = 0; i < 9; i++) {\n      X[row * 9 + i] = X[row * 9 + i] / w[row];\n    }\n  }\n\n  if (typeof window !== 'undefined' && window.DEBUG_MATCH) {\n    const dX = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].X;\n    const dw = window.debugMatch.querykeyframes[window.debug.querykeyframeIndex].homography[window.debug.homographyIndex].w;\n    if (!window.cmpArray(X, dX, 0.01)) {\n      console.log(\"INCORRECT X\", window.debug.querykeyframeIndex, window.debug.homographyIndex, JSON.parse(JSON.stringify(X)), dX);\n    }\n    if (!window.cmpArray(w, dw, 0.01)) {\n      console.log(\"INCORRECT w\", window.debug.querykeyframeIndex, window.debug.homographyIndex, JSON.parse(JSON.stringify(w)), dw);\n    }\n  }\n\n  let maxRow = -1;\n  let maxValue = -1;\n  for (let j = 0; j < 9; j++) {\n    if (w[j] > maxValue) {\n      maxRow = j;\n      maxValue = w[j];\n    }\n  }\n\n\n  if (maxValue == 0) return null; // no solution\n\n  const x = [];\n  for (let i = 0; i < 9; i++) {\n    x[i] = X[maxRow * 9 + i];\n  }\n\n  return x;\n}\n\nmodule.exports = {\n  computeHomography,\n}\n\n\n\n//# sourceURL=webpack:///./src/image-target/matching/homography.js?");

/***/ }),

/***/ "./src/image-target/matching/hough.js":
/*!********************************************!*\
  !*** ./src/image-target/matching/hough.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const kHoughBinDelta = 1;\n\n// mathces [querypointIndex:x, keypointIndex: x]\nconst computeHoughMatches = (options) => {\n  const {keypoints, querypoints, keywidth, keyheight, querywidth, queryheight, matches} = options;\n\n  const maxX = querywidth * 1.2;\n  const minX = -maxX;\n  const maxY = queryheight * 1.2;\n  const minY = -maxY;\n  const numAngleBins = 12;\n  const numScaleBins = 10;\n  const minScale = -1;\n  const maxScale = 1;\n  const scaleK = 10.0;\n  const scaleOneOverLogK = 1.0 / Math.log(scaleK);\n  const maxDim = Math.max(keywidth, keyheight);\n  const keycenterX = Math.floor(keywidth / 2);\n  const keycenterY = Math.floor(keyheight / 2);\n\n  // compute numXBins and numYBins based on matches\n  const projectedDims = [];\n  for (let i = 0; i < matches.length; i++) {\n    const queryscale = querypoints[matches[i].querypointIndex].scale;\n    const keyscale = keypoints[matches[i].keypointIndex].scale;\n    if (keyscale == 0) console.log(\"ERROR divide zero\");\n    const scale = queryscale / keyscale;\n    projectedDims.push( scale * maxDim );\n  }\n\n  // TODO optimize median\n  //   weird. median should be [Math.floor(projectedDims.length/2) - 1] ?\n  projectedDims.sort((a1, a2) => {return a1 - a2});\n  const medianProjectedDim = projectedDims[ Math.floor(projectedDims.length/2) - (projectedDims.length%2==0?1:0) -1 ];\n\n  const binSize = 0.25 * medianProjectedDim;\n  const numXBins = Math.max(5, Math.ceil((maxX - minX) / binSize));\n  const numYBins = Math.max(5, Math.ceil((maxY - minY) / binSize));\n\n  const numXYBins = numXBins * numYBins;\n  const numXYAngleBins = numXYBins * numAngleBins;\n\n  // do voting\n  const querypointValids = [];\n  const querypointBinLocations = [];\n  const votes = {};\n  for (let i = 0; i < matches.length; i++) {\n    const querypoint = querypoints[matches[i].querypointIndex];\n    const keypoint = keypoints[matches[i].keypointIndex];\n\n    const {x, y, scale, angle} = _mapCorrespondence({querypoint, keypoint, keycenterX, keycenterY, scaleOneOverLogK});\n\n    // Check that the vote is within range\n    if (x < minX || x >= maxX || y < minY || y >= maxY || angle <= -Math.PI || angle > Math.PI || scale < minScale || scale >= maxScale) {\n      querypointValids[i] = false;\n      continue;\n    }\n\n    // map properties to bins\n    let fbinX = numXBins * (x - minX) / (maxX - minX);\n    let fbinY = numYBins * (y - minY) / (maxY - minY);\n    let fbinAngle = numAngleBins * (angle + Math.PI) / (2.0 * Math.PI);\n    let fbinScale = numScaleBins * (scale - minScale) / (maxScale - minScale);\n\n    querypointBinLocations[i] = {binX: fbinX, binY: fbinY, binAngle: fbinAngle, binScale: fbinScale};\n\n    let binX = Math.floor(fbinX - 0.5);\n    let binY = Math.floor(fbinY - 0.5);\n    let binScale = Math.floor(fbinScale - 0.5);\n    let binAngle = (Math.floor(fbinAngle - 0.5) + numAngleBins) % numAngleBins;\n\n    // check can vote all 16 bins\n    if (binX < 0 || binX + 1 >= numXBins || binY < 0 || binY + 1 >= numYBins || binScale < 0 || binScale +1 >= numScaleBins) {\n      querypointValids[i] = false;\n      continue;\n    }\n\n    for (let dx = 0; dx < 2; dx++) {\n      let binX2 = binX + dx;\n\n      for (let dy = 0; dy < 2; dy++) {\n        let binY2 = binY + dy;\n\n        for (let dangle = 0; dangle < 2; dangle++) {\n          let binAngle2 = (binAngle + dangle) % numAngleBins;\n\n          for (let dscale = 0; dscale < 2; dscale++) {\n            let binScale2 = binScale + dscale;\n\n            const binIndex = binX2 + binY2 * numXBins + binAngle2 * numXYBins + binScale2 * numXYAngleBins;\n\n            if (votes[binIndex] === undefined) votes[binIndex] = 0;\n            votes[binIndex] += 1;\n          }\n        }\n      }\n    }\n    querypointValids[i] = true;\n  }\n\n  let maxVotes = 0;\n  let maxVoteIndex = -1;\n  Object.keys(votes).forEach((index) => {\n    if (votes[index] > maxVotes) {\n      maxVotes = votes[index];\n      maxVoteIndex = index;\n    }\n  });\n\n  if (maxVotes < 3) return [];\n\n  // get back bins from vote index\n  const binX = Math.floor(((maxVoteIndex % numXYAngleBins) % numXYBins) % numXBins);\n  const binY = Math.floor((((maxVoteIndex - binX) % numXYAngleBins) % numXYBins) / numXBins);\n  const binAngle = Math.floor(((maxVoteIndex - binX - (binY * numXBins)) % numXYAngleBins) / numXYBins);\n  const binScale = Math.floor((maxVoteIndex - binX - (binY * numXBins) - (binAngle * numXYBins)) / numXYAngleBins);\n\n  //console.log(\"hough voted: \", {binX, binY, binAngle, binScale, maxVoteIndex});\n\n  const houghMatches = [];\n  for (let i = 0; i < matches.length; i++) {\n    if (!querypointValids[i]) continue;\n\n    const queryBins = querypointBinLocations[i];\n    // compute bin difference\n    const distBinX = Math.abs(queryBins.binX - (binX+0.5));\n    if (distBinX >= kHoughBinDelta) continue;\n\n    const distBinY = Math.abs(queryBins.binY - (binY+0.5));\n    if (distBinY >= kHoughBinDelta) continue;\n\n    const distBinScale = Math.abs(queryBins.binScale - (binScale+0.5));\n    if (distBinScale >= kHoughBinDelta) continue;\n\n    const temp = Math.abs(queryBins.binAngle - (binAngle+0.5));\n    const distBinAngle = Math.min(temp, numAngleBins - temp);\n    if (distBinAngle >= kHoughBinDelta) continue;\n\n    houghMatches.push(matches[i]);\n  }\n  return houghMatches;\n}\n\nconst _mapCorrespondence = ({querypoint, keypoint, keycenterX, keycenterY, scaleOneOverLogK}) => {\n  // map angle to (-pi, pi]\n  let angle = querypoint.angle - keypoint.angle;\n  if (angle <= -Math.PI) angle += 2*Math.PI;\n  else if (angle > Math.PI) angle -= 2*Math.PI;\n\n  const scale = querypoint.scale / keypoint.scale;\n\n  // 2x2 similarity\n  const cos = scale * Math.cos(angle);\n  const sin = scale * Math.sin(angle);\n  const S = [cos, -sin, sin, cos];\n\n  const tp = [\n    S[0] * keypoint.x2D + S[1] * keypoint.y2D,\n    S[2] * keypoint.x2D + S[3] * keypoint.y2D\n  ];\n  const tx = querypoint.x2D - tp[0];\n  const ty = querypoint.y2D - tp[1];\n\n  return {\n    x: S[0] * keycenterX + S[1] * keycenterY + tx,\n    y: S[2] * keycenterX + S[3] * keycenterY + ty,\n    angle: angle,\n    scale: Math.log(scale) * scaleOneOverLogK\n  }\n}\n\nmodule.exports = {\n  computeHoughMatches\n}\n\n\n\n//# sourceURL=webpack:///./src/image-target/matching/hough.js?");

/***/ }),

/***/ "./src/image-target/matching/matcher.js":
/*!**********************************************!*\
  !*** ./src/image-target/matching/matcher.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const {match} = __webpack_require__(/*! ./matching */ \"./src/image-target/matching/matching.js\");\n\nclass Matcher {\n  constructor(queryWidth, queryHeight) {\n    this.queryWidth = queryWidth;\n    this.queryHeight = queryHeight;\n  }\n\n  matchDetection(keyframes, featurePoints) {\n    const result = match({keyframes: keyframes, querypoints: featurePoints, querywidth: this.queryWidth, queryheight: this.queryHeight});\n    if (result === null) return null;\n\n    const screenCoords = [];\n    const worldCoords = [];\n    const keyframe = keyframes[result.keyframeIndex];\n\n    for (let i = 0; i < result.matches.length; i++) {\n      const querypointIndex = result.matches[i].querypointIndex;\n      const keypointIndex = result.matches[i].keypointIndex;\n      screenCoords.push({\n        x: featurePoints[querypointIndex].x,\n        y: featurePoints[querypointIndex].y,\n      })\n      worldCoords.push({\n        x: (keyframe.points[keypointIndex].x + 0.5) / keyframe.scale,\n        y: ((keyframe.height-0.5) -keyframe.points[keypointIndex].y) / keyframe.scale,\n        z: 0,\n      })\n    }\n\n    return {screenCoords, worldCoords, keyframeIndex: result.keyframeIndex};\n  }\n}\n\nmodule.exports = {\n  Matcher\n}\n\n\n//# sourceURL=webpack:///./src/image-target/matching/matcher.js?");

/***/ }),

/***/ "./src/image-target/matching/matching.js":
/*!***********************************************!*\
  !*** ./src/image-target/matching/matching.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const TinyQueue = __webpack_require__(/*! tinyqueue */ \"./node_modules/tinyqueue/index.js\").default;\nconst {compute: hammingCompute} = __webpack_require__(/*! ./hamming-distance.js */ \"./src/image-target/matching/hamming-distance.js\");\nconst {computeHoughMatches} = __webpack_require__(/*! ./hough.js */ \"./src/image-target/matching/hough.js\");\nconst {computeHomography} = __webpack_require__(/*! ./homography.js */ \"./src/image-target/matching/homography.js\");\nconst {multiplyPointHomographyInhomogenous, matrixInverse33} = __webpack_require__(/*! ../utils/geometry.js */ \"./src/image-target/utils/geometry.js\");\n\nconst INLIER_THRESHOLD = 3;\n//const MIN_NUM_INLIERS = 8;  //default\nconst MIN_NUM_INLIERS = 6;\nconst CLUSTER_MAX_POP = 8;\nconst HAMMING_THRESHOLD = 0.7;\n\n// match list of querpoints against pre-built list of keyframes\nconst match = ({keyframes, querypoints, querywidth, queryheight}) => {\n  let result = null;\n\n  for (let i = 0; i < keyframes.length; i++) {\n    const keyframe = keyframes[i];\n    const keypoints = keyframe.points;\n\n    const matches = [];\n    for (let j = 0; j < querypoints.length; j++) {\n      const rootNode = keyframe.pointsCluster.rootNode;\n      const querypoint = querypoints[j];\n      const keypointIndexes = [];\n      const queue = new TinyQueue([], (a1, a2) => {return a1.d - a2.d});\n\n      _query({node: rootNode, keypoints, querypoint, queue, keypointIndexes, numPop: 0});\n\n      let bestIndex = -1;\n      let bestD1 = Number.MAX_SAFE_INTEGER;\n      let bestD2 = Number.MAX_SAFE_INTEGER;\n\n      for (let k = 0; k < keypointIndexes.length; k++) {\n        const keypoint = keypoints[keypointIndexes[k]];\n        if (keypoint.maxima != querypoint.maxima) continue;\n\n        const d = hammingCompute({v1: keypoint.descriptors, v2: querypoint.descriptors});\n        if (d < bestD1) {\n          bestD2 = bestD1;\n          bestD1 = d;\n          bestIndex = keypointIndexes[k];\n        } else if (d < bestD2) {\n          bestD2 = d;\n        }\n      }\n      if (bestIndex !== -1 && (bestD2 === Number.MAX_SAFE_INTEGER || (1.0 * bestD1 / bestD2) < HAMMING_THRESHOLD)) {\n        matches.push({querypointIndex: j, keypointIndex: bestIndex});\n      }\n    }\n\n    if (matches.length < MIN_NUM_INLIERS) {\n      continue;\n    }\n\n    const houghMatches = computeHoughMatches({\n      keypoints: keyframe.points,\n      querypoints,\n      keywidth: keyframe.width,\n      keyheight: keyframe.height,\n      querywidth,\n      queryheight,\n      matches,\n    });\n\n    const srcPoints = [];\n    const dstPoints = [];\n    for (let i = 0; i < houghMatches.length; i++) {\n      const querypoint = querypoints[houghMatches[i].querypointIndex];\n      const keypoint = keypoints[houghMatches[i].keypointIndex];\n      srcPoints.push([ keypoint.x, keypoint.y ]);\n      dstPoints.push([ querypoint.x, querypoint.y ]);\n    }\n\n    const H = computeHomography({\n      srcPoints,\n      dstPoints,\n      keyframe,\n    });\n\n    if (H === null) continue;\n\n    const inlierMatches = _findInlierMatches({\n      querypoints,\n      keypoints: keyframe.points,\n      H,\n      matches: houghMatches,\n      threshold: INLIER_THRESHOLD\n    });\n\n\n    if (inlierMatches.length < MIN_NUM_INLIERS) {\n      continue;\n    }\n\n    // do another loop of match using the homography\n    const HInv = matrixInverse33(H, 0.00001);\n    const dThreshold2 = 10 * 10;\n    const matches2 = [];\n    for (let j = 0; j < querypoints.length; j++) {\n      const querypoint = querypoints[j];\n      const mapquerypoint = multiplyPointHomographyInhomogenous([querypoint.x, querypoint.y], HInv);\n\n      let bestIndex = -1;\n      let bestD1 = Number.MAX_SAFE_INTEGER;\n      let bestD2 = Number.MAX_SAFE_INTEGER;\n\n      for (let k = 0; k < keypoints.length; k++) {\n        const keypoint = keypoints[k];\n        if (keypoint.maxima != querypoint.maxima) continue;\n\n        // check distance threshold\n        const d2 = (keypoint.x - mapquerypoint[0]) * (keypoint.x - mapquerypoint[0])\n                  + (keypoint.y - mapquerypoint[1]) * (keypoint.y - mapquerypoint[1]);\n        if (d2 > dThreshold2) continue;\n\n        const d = hammingCompute({v1: keypoint.descriptors, v2: querypoint.descriptors});\n        if (d < bestD1) {\n          bestD2 = bestD1;\n          bestD1 = d;\n          bestIndex = k;\n        } else if (d < bestD2) {\n          bestD2 = d;\n        }\n      }\n\n      if (bestIndex !== -1 && (bestD2 === Number.MAX_SAFE_INTEGER || (1.0 * bestD1 / bestD2) < HAMMING_THRESHOLD)) {\n        matches2.push({querypointIndex: j, keypointIndex: bestIndex});\n      }\n    }\n\n    const houghMatches2 = computeHoughMatches({\n      keypoints: keyframe.points,\n      querypoints,\n      keywidth: keyframe.width,\n      keyheight: keyframe.height,\n      querywidth,\n      queryheight,\n      matches: matches2,\n    });\n\n    const srcPoints2 = [];\n    const dstPoints2 = [];\n    for (let i = 0; i < houghMatches2.length; i++) {\n      const querypoint = querypoints[houghMatches2[i].querypointIndex];\n      const keypoint = keypoints[houghMatches2[i].keypointIndex];\n      srcPoints2.push([ keypoint.x, keypoint.y ]);\n      dstPoints2.push([ querypoint.x, querypoint.y ]);\n    }\n\n    const H2 = computeHomography({\n      srcPoints: srcPoints2,\n      dstPoints: dstPoints2,\n      keyframe\n    });\n\n    if (H2 === null) continue;\n\n    const inlierMatches2 = _findInlierMatches({\n      querypoints,\n      keypoints: keyframe.points,\n      H: H2,\n      matches: houghMatches2,\n      threshold: INLIER_THRESHOLD\n    });\n\n    if (inlierMatches2.length < MIN_NUM_INLIERS) {\n      continue;\n    }\n\n    if (result === null || result.matches.length < inlierMatches2.length) {\n      result = {\n        keyframeIndex: i,\n        matches: inlierMatches2,\n        H: H2,\n      }\n    }\n  }\n\n  return result;\n};\n\nconst _query = ({node, keypoints, querypoint, queue, keypointIndexes, numPop}) => {\n  if (node.leaf) {\n    for (let i = 0; i < node.pointIndexes.length; i++) {\n      keypointIndexes.push(node.pointIndexes[i]);\n    }\n    return;\n  }\n\n  const distances = [];\n  for (let i = 0; i < node.children.length; i++) {\n    const childNode = node.children[i];\n    const centerPointIndex = childNode.centerPointIndex;\n    const d = hammingCompute({v1: keypoints[centerPointIndex].descriptors, v2: querypoint.descriptors});\n    distances.push(d);\n  }\n\n  let minD = Number.MAX_SAFE_INTEGER;\n  for (let i = 0; i < node.children.length; i++) {\n    minD = Math.min(minD, distances[i]);\n  }\n\n  for (let i = 0; i < node.children.length; i++) {\n    if (distances[i] !== minD) {\n      queue.push({node: node.children[i], d: distances[i]});\n    }\n  }\n  for (let i = 0; i < node.children.length; i++) {\n    if (distances[i] === minD) {\n      _query({node: node.children[i], keypoints, querypoint, queue, keypointIndexes, numPop});\n    }\n  }\n\n  if (numPop < CLUSTER_MAX_POP && queue.length > 0) {\n    const {node, d} = queue.pop();\n    numPop += 1;\n    _query({node, keypoints, querypoint, queue, keypointIndexes, numPop});\n  }\n};\n\nconst _findInlierMatches = (options) => {\n  const {keypoints, querypoints, H, matches, threshold} = options;\n\n  const threshold2 = threshold * threshold;\n\n  const goodMatches = [];\n  for (let i = 0; i < matches.length; i++) {\n    const querypoint = querypoints[matches[i].querypointIndex];\n    const keypoint = keypoints[matches[i].keypointIndex];\n    const mp = multiplyPointHomographyInhomogenous([keypoint.x, keypoint.y], H);\n    const d2 = (mp[0] - querypoint.x) * (mp[0] - querypoint.x) + (mp[1] - querypoint.y) * (mp[1] - querypoint.y);\n    if (d2 <= threshold2) {\n      goodMatches.push( matches[i] );\n    }\n  }\n  return goodMatches;\n}\n\nmodule.exports = {\n  match\n}\n\n\n//# sourceURL=webpack:///./src/image-target/matching/matching.js?");

/***/ }),

/***/ "./src/image-target/utils/geometry.js":
/*!********************************************!*\
  !*** ./src/image-target/utils/geometry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// check which side point C on the line from A to B\nconst linePointSide = (A, B, C) => {\n  return ((B[0]-A[0])*(C[1]-A[1])-(B[1]-A[1])*(C[0]-A[0]));\n}\n\n// srcPoints, dstPoints: array of four elements [x, y]\nconst checkFourPointsConsistent = (x1, x2, x3, x4, x1p, x2p, x3p, x4p) => {\n  if ((linePointSide(x1, x2, x3) > 0) !== (linePointSide(x1p, x2p, x3p) > 0)) return false;\n  if ((linePointSide(x2, x3, x4) > 0) !== (linePointSide(x2p, x3p, x4p) > 0)) return false;\n  if ((linePointSide(x3, x4, x1) > 0) !== (linePointSide(x3p, x4p, x1p) > 0)) return false;\n  if ((linePointSide(x4, x1, x2) > 0) !== (linePointSide(x4p, x1p, x2p) > 0)) return false;\n  return true;\n}\n\nconst checkThreePointsConsistent = (x1, x2, x3, x1p, x2p, x3p) => {\n  if ((linePointSide(x1, x2, x3) > 0) !== (linePointSide(x1p, x2p, x3p) > 0)) return false;\n  return true;\n}\n\nconst determinant = (A) => {\n  const C1 =  A[4] * A[8] - A[5] * A[7];\n  const C2 =  A[3] * A[8] - A[5] * A[6];\n  const C3 =  A[3] * A[7] - A[4] * A[6];\n  return A[0] * C1 - A[1] * C2 + A[2] * C3;\n}\n\nconst matrixInverse33 = (A, threshold) => {\n  const det = determinant(A);\n  if (Math.abs(det) <= threshold) return null;\n  const oneOver = 1.0 / det;\n\n  const B = [\n    (A[4] * A[8] - A[5] * A[7]) * oneOver,\n    (A[2] * A[7] - A[1] * A[8]) * oneOver,\n    (A[1] * A[5] - A[2] * A[4]) * oneOver,\n    (A[5] * A[6] - A[3] * A[8]) * oneOver,\n    (A[0] * A[8] - A[2] * A[6]) * oneOver,\n    (A[2] * A[3] - A[0] * A[5]) * oneOver,\n    (A[3] * A[7] - A[4] * A[6]) * oneOver,\n    (A[1] * A[6] - A[0] * A[7]) * oneOver,\n    (A[0] * A[4] - A[1] * A[3]) * oneOver,\n  ];\n  return B;\n}\n\nconst matrixMul33 = (A, B) => {\n  const C = [];\n  C[0] = A[0]*B[0] + A[1]*B[3] + A[2]*B[6];\n  C[1] = A[0]*B[1] + A[1]*B[4] + A[2]*B[7];\n  C[2] = A[0]*B[2] + A[1]*B[5] + A[2]*B[8];\n  C[3] = A[3]*B[0] + A[4]*B[3] + A[5]*B[6];\n  C[4] = A[3]*B[1] + A[4]*B[4] + A[5]*B[7];\n  C[5] = A[3]*B[2] + A[4]*B[5] + A[5]*B[8];\n  C[6] = A[6]*B[0] + A[7]*B[3] + A[8]*B[6];\n  C[7] = A[6]*B[1] + A[7]*B[4] + A[8]*B[7];\n  C[8] = A[6]*B[2] + A[7]*B[5] + A[8]*B[8];\n  return C;\n}\n\nconst multiplyPointHomographyInhomogenous = (x, H) => {\n  const w = H[6]*x[0] + H[7]*x[1] + H[8];\n  const xp = [];\n  xp[0] = (H[0]*x[0] + H[1]*x[1] + H[2])/w;\n  xp[1] = (H[3]*x[0] + H[4]*x[1] + H[5])/w;\n  return xp;\n}\n\nconst smallestTriangleArea = (x1, x2, x3, x4) => {\n  const v12 = _vector(x2, x1);\n  const v13 = _vector(x3, x1);\n  const v14 = _vector(x4, x1);\n  const v32 = _vector(x2, x3);\n  const v34 = _vector(x4, x3);\n  const a1 = _areaOfTriangle(v12, v13);\n  const a2 = _areaOfTriangle(v13, v14);\n  const a3 = _areaOfTriangle(v12, v14);\n  const a4 = _areaOfTriangle(v32, v34);\n  return Math.min(Math.min(Math.min(a1, a2), a3), a4);\n}\n\n// check if four points form a convex quadrilaternal.\n// all four combinations should have same sign\nconst quadrilateralConvex = (x1, x2, x3, x4) => {\n  const first = linePointSide(x1, x2, x3) <= 0;\n  if ( (linePointSide(x2, x3, x4) <= 0) !== first) return false;\n  if ( (linePointSide(x3, x4, x1) <= 0) !== first) return false;\n  if ( (linePointSide(x4, x1, x2) <= 0) !== first) return false;\n\n  //if (linePointSide(x1, x2, x3) <= 0) return false;\n  //if (linePointSide(x2, x3, x4) <= 0) return false;\n  //if (linePointSide(x3, x4, x1) <= 0) return false;\n  //if (linePointSide(x4, x1, x2) <= 0) return false;\n  return true;\n}\n\nconst _vector = (a, b) => {\n  return [\n    a[0] - b[0],\n    a[1] - b[1]\n  ]\n}\n\nconst _areaOfTriangle = (u, v) => {\n  const a = u[0]*v[1] - u[1]*v[0];\n  return Math.abs(a) * 0.5;\n}\n\nmodule.exports = {\n  matrixInverse33,\n  matrixMul33,\n  quadrilateralConvex,\n  smallestTriangleArea,\n  multiplyPointHomographyInhomogenous,\n  checkThreePointsConsistent,\n  checkFourPointsConsistent,\n  determinant\n}\n\n\n\n//# sourceURL=webpack:///./src/image-target/utils/geometry.js?");

/***/ }),

/***/ "./src/image-target/utils/randomizer.js":
/*!**********************************************!*\
  !*** ./src/image-target/utils/randomizer.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const mRandSeed = 1234;\n\nconst createRandomizer = () => {\n  const randomizer = {\n    seed: mRandSeed,\n\n    arrayShuffle(options) {\n      const {arr, sampleSize} = options;\n      for (let i = 0; i < sampleSize; i++) {\n\n        this.seed = (214013 * this.seed + 2531011) % (1 << 31);\n        let k = (this.seed >> 16) & 0x7fff;\n        k = k % arr.length;\n\n        let tmp = arr[i];\n        arr[i] = arr[k];\n        arr[k] = tmp;\n      }\n    },\n\n    nextInt(maxValue) {\n      this.seed = (214013 * this.seed + 2531011) % (1 << 31);\n      let k = (this.seed >> 16) & 0x7fff;\n      k = k % maxValue;\n      return k;\n    }\n  }\n  return randomizer;\n}\n\nmodule.exports = {\n  createRandomizer\n}\n\n\n//# sourceURL=webpack:///./src/image-target/utils/randomizer.js?");

/***/ })

/******/ });